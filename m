Return-Path: <linux-kernel+bounces-362540-lists+linux-kernel=lfdr.de@vger.kernel.org>
X-Original-To: lists+linux-kernel@lfdr.de
Delivered-To: lists+linux-kernel@lfdr.de
Received: from am.mirrors.kernel.org (am.mirrors.kernel.org [147.75.80.249])
	by mail.lfdr.de (Postfix) with ESMTPS id 14D8699B619
	for <lists+linux-kernel@lfdr.de>; Sat, 12 Oct 2024 18:49:59 +0200 (CEST)
Received: from smtp.subspace.kernel.org (wormhole.subspace.kernel.org [52.25.139.140])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by am.mirrors.kernel.org (Postfix) with ESMTPS id 1AA131F224FC
	for <lists+linux-kernel@lfdr.de>; Sat, 12 Oct 2024 16:49:57 +0000 (UTC)
Received: from localhost.localdomain (localhost.localdomain [127.0.0.1])
	by smtp.subspace.kernel.org (Postfix) with ESMTP id 2263E50276;
	Sat, 12 Oct 2024 16:49:53 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=gmail.com header.i=@gmail.com header.b="I3Zs7502"
Received: from mail-ej1-f49.google.com (mail-ej1-f49.google.com [209.85.218.49])
	(using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 6EEEC175BF
	for <linux-kernel@vger.kernel.org>; Sat, 12 Oct 2024 16:49:41 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=209.85.218.49
ARC-Seal:i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1728751788; cv=none; b=BtbhUQh9ShR5YQMPiKZUCht02R1mLrR2659WDvgVsJp4NG0c1HHOoj82npyaCRxJMCz/QjVYgLNJ4j6uUBwH8Tzd9ElFgjh+wRYSDfdsfPm6oFLrtTmS9KH5G50mln7feSO7kNxTeVF258Q5XaNaWz29MlS8WXAX6AbPDbFihdk=
ARC-Message-Signature:i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1728751788; c=relaxed/simple;
	bh=ciRfPlO10bGHQILmSpu1R3v6pTnFZgQ6jFJ6P9tbWuA=;
	h=From:To:Cc:Subject:Date:Message-ID:MIME-Version; b=egv1Ujg65wJstyD/l6zqxYLJqc7G+QgYE5AAaj1ir968mCZPhizvMYyzSHvG0BxEsc+1lNmMrQtEoQ9b6ef+BBX9c361HM5WG5EUzdqW24STdBTx1f7yoSwdbv+EJnOoP3jXSjYTL9q8EDOuC8Iu7fPA4eX2UbdxcvzQuFkgRgI=
ARC-Authentication-Results:i=1; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=gmail.com; spf=pass smtp.mailfrom=gmail.com; dkim=pass (2048-bit key) header.d=gmail.com header.i=@gmail.com header.b=I3Zs7502; arc=none smtp.client-ip=209.85.218.49
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=gmail.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=gmail.com
Received: by mail-ej1-f49.google.com with SMTP id a640c23a62f3a-a993302fa02so476463166b.0
        for <linux-kernel@vger.kernel.org>; Sat, 12 Oct 2024 09:49:41 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20230601; t=1728751780; x=1729356580; darn=vger.kernel.org;
        h=content-transfer-encoding:mime-version:message-id:date:subject:cc
         :to:from:from:to:cc:subject:date:message-id:reply-to;
        bh=1pYephcz1ZJyBBpX0zXMQSNf0d08P/Yid0SK7oERxTM=;
        b=I3Zs7502IjY32JUogw2k1sRVhMpgsMvhm2JJ6PEw0tOHP+yPJkSH6UQhLsCFCNDto0
         1823Y6P/TVNJWO4lUSjWMQKPyF0yt/UYZ7xk4iWISrXB2JkvlWAMyrHMH9pxo7FI/RZn
         WEXJgPICgTviqUHk4mTvc/7BuCVwhCiYDgACACwWqQ/DvBFsYMXYHLKQr/FAFfn8nf3D
         w7oY0LmFFVMxpwgZ6HX29KfeFq9402jKKVRXmlOIWHYTqeZvqRHNycaqe1/9JXDzKJXG
         BmoF8XAkxs4UAY6CBuK4jW5DDjETCzEBHmw5Wn2e4J2bd0Cw9T9FxZHLgbOXhDNGWdJP
         XzsQ==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20230601; t=1728751780; x=1729356580;
        h=content-transfer-encoding:mime-version:message-id:date:subject:cc
         :to:from:x-gm-message-state:from:to:cc:subject:date:message-id
         :reply-to;
        bh=1pYephcz1ZJyBBpX0zXMQSNf0d08P/Yid0SK7oERxTM=;
        b=FqjpZThoTqKeicFn5oNuE+dB+vRPFF/yuRWh9z2rLOfxnX2n6vWhibUJnKE48/QGvv
         MSqUeS4M1FgUwQJV/TjFWaFL3V281YwJM7jDu6ZJDU0pF2fqBqKaEHOD08ff6AIBg51x
         Mhd/5PYll1kFm9sUl6gOMPiGJXWGd5x9I2tNJZw6m0HncVzMogr/XEq5wDL4HwYjH0P/
         X19712k9cgSXyNRxsQlzfv6T7w+TLcS3nZ29BUw+j9UZzKTfTiApj+gBR6o2ziZ0BAZq
         /7aY7hK3x77uyYaQRsUaJM8BOqrRRa/L8SXbQlokK9wY3PAODTgsTDSibZW4RkQ8GUXu
         Onug==
X-Forwarded-Encrypted: i=1; AJvYcCX7/L7GzSzuAFe+2OAeen9orb39l1jDw5X3M72XGQs81X4n7W3kN0eP/b85mehudNe/Pr8OLeL3YI+zFLA=@vger.kernel.org
X-Gm-Message-State: AOJu0YwggBRIlE2mo/kj9vx7+RGqwzqaHtQ0cj2VyROg6cAvIsMcwgGL
	UyX2MwgO9ryNgNU3xLl4Oomyvn2SIhnwVr9UKY+zs+ez5LV/r2w0
X-Google-Smtp-Source: AGHT+IEegdR5mQmo9/y4is2sip4UgED2thfX+Hx0fanL+zt8iEMer1R2emC3RkBk53prBonQ4ninsA==
X-Received: by 2002:a17:906:d7d4:b0:a99:f8db:68b2 with SMTP id a640c23a62f3a-a99f8db6bd0mr85343966b.18.1728751778562;
        Sat, 12 Oct 2024 09:49:38 -0700 (PDT)
Received: from kernel-710.speedport.ip (p54a0712c.dip0.t-ipconnect.de. [84.160.113.44])
        by smtp.gmail.com with ESMTPSA id a640c23a62f3a-a99f752b7d5sm42268266b.217.2024.10.12.09.49.37
        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
        Sat, 12 Oct 2024 09:49:37 -0700 (PDT)
From: Philipp Hortmann <philipp.g.hortmann@gmail.com>
To: Greg Kroah-Hartman <gregkh@linuxfoundation.org>,
	linux-staging@lists.linux.dev,
	linux-kernel@vger.kernel.org
Cc: Philipp Hortmann <philipp.g.hortmann@gmail.com>
Subject: [PATCH] staging: vt6656: Remove unused driver
Date: Sat, 12 Oct 2024 18:49:24 +0200
Message-ID: <20241012164932.26390-1-philipp.g.hortmann@gmail.com>
X-Mailer: git-send-email 2.43.0
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit

Forest Bond contributed this driver in 2009.

The following reasons lead to the removal:
- This driver generates maintenance workload
- This driver has a maximum 54MBit/s as it supports only 802.11 b/g.
  Peak throughput is 3MBytes/s.
- ping times can be 17ms are often above 500ms and worst case 22 seconds.
  One other user does not see such long ping times using a rasperry pi.

I suggest deleting the driver as it no longer meets current expectations
for throuput.

Link: https://lore.kernel.org/linux-staging/d18e714d-787f-4d30-a32f-4b0f55d2f5be@gmail.com/T/#t
Signed-off-by: Philipp Hortmann <philipp.g.hortmann@gmail.com>
---
Artifacts of vt6656 in MAINTAINERS are removed with this patch.
Removed artifacts in Makefile and Kconfig.
---
 MAINTAINERS                       |    5 -
 drivers/staging/Kconfig           |    2 -
 drivers/staging/Makefile          |    1 -
 drivers/staging/vt6656/Kconfig    |    7 -
 drivers/staging/vt6656/Makefile   |   15 -
 drivers/staging/vt6656/TODO       |   17 -
 drivers/staging/vt6656/baseband.c |  455 ------------
 drivers/staging/vt6656/baseband.h |   75 --
 drivers/staging/vt6656/card.c     |  456 ------------
 drivers/staging/vt6656/card.h     |   44 --
 drivers/staging/vt6656/channel.c  |   77 --
 drivers/staging/vt6656/channel.h  |   21 -
 drivers/staging/vt6656/desc.h     |   91 ---
 drivers/staging/vt6656/device.h   |  386 ----------
 drivers/staging/vt6656/key.c      |  142 ----
 drivers/staging/vt6656/key.h      |   40 -
 drivers/staging/vt6656/mac.c      |  183 -----
 drivers/staging/vt6656/mac.h      |  373 ----------
 drivers/staging/vt6656/main_usb.c | 1121 -----------------------------
 drivers/staging/vt6656/power.c    |  112 ---
 drivers/staging/vt6656/power.h    |   23 -
 drivers/staging/vt6656/rf.c       |  443 ------------
 drivers/staging/vt6656/rf.h       |   46 --
 drivers/staging/vt6656/rxtx.c     |  730 -------------------
 drivers/staging/vt6656/rxtx.h     |  178 -----
 drivers/staging/vt6656/usbpipe.c  |  506 -------------
 drivers/staging/vt6656/usbpipe.h  |   67 --
 drivers/staging/vt6656/wcmd.c     |  185 -----
 drivers/staging/vt6656/wcmd.h     |   48 --
 29 files changed, 5849 deletions(-)
 delete mode 100644 drivers/staging/vt6656/Kconfig
 delete mode 100644 drivers/staging/vt6656/Makefile
 delete mode 100644 drivers/staging/vt6656/TODO
 delete mode 100644 drivers/staging/vt6656/baseband.c
 delete mode 100644 drivers/staging/vt6656/baseband.h
 delete mode 100644 drivers/staging/vt6656/card.c
 delete mode 100644 drivers/staging/vt6656/card.h
 delete mode 100644 drivers/staging/vt6656/channel.c
 delete mode 100644 drivers/staging/vt6656/channel.h
 delete mode 100644 drivers/staging/vt6656/desc.h
 delete mode 100644 drivers/staging/vt6656/device.h
 delete mode 100644 drivers/staging/vt6656/key.c
 delete mode 100644 drivers/staging/vt6656/key.h
 delete mode 100644 drivers/staging/vt6656/mac.c
 delete mode 100644 drivers/staging/vt6656/mac.h
 delete mode 100644 drivers/staging/vt6656/main_usb.c
 delete mode 100644 drivers/staging/vt6656/power.c
 delete mode 100644 drivers/staging/vt6656/power.h
 delete mode 100644 drivers/staging/vt6656/rf.c
 delete mode 100644 drivers/staging/vt6656/rf.h
 delete mode 100644 drivers/staging/vt6656/rxtx.c
 delete mode 100644 drivers/staging/vt6656/rxtx.h
 delete mode 100644 drivers/staging/vt6656/usbpipe.c
 delete mode 100644 drivers/staging/vt6656/usbpipe.h
 delete mode 100644 drivers/staging/vt6656/wcmd.c
 delete mode 100644 drivers/staging/vt6656/wcmd.h

diff --git a/MAINTAINERS b/MAINTAINERS
index 0f87adc74bb9..89e71b6fb431 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -21982,11 +21982,6 @@ L:	linux-fbdev@vger.kernel.org
 S:	Maintained
 F:	drivers/staging/sm750fb/
 
-STAGING - VIA VT665X DRIVERS
-M:	Philipp Hortmann <philipp.g.hortmann@gmail.com>
-S:	Odd Fixes
-F:	drivers/staging/vt665?/
-
 STAGING SUBSYSTEM
 M:	Greg Kroah-Hartman <gregkh@linuxfoundation.org>
 L:	linux-staging@lists.linux.dev
diff --git a/drivers/staging/Kconfig b/drivers/staging/Kconfig
index 2493e150fbbd..b7f089e071cc 100644
--- a/drivers/staging/Kconfig
+++ b/drivers/staging/Kconfig
@@ -32,8 +32,6 @@ source "drivers/staging/rtl8712/Kconfig"
 
 source "drivers/staging/octeon/Kconfig"
 
-source "drivers/staging/vt6656/Kconfig"
-
 source "drivers/staging/iio/Kconfig"
 
 source "drivers/staging/sm750fb/Kconfig"
diff --git a/drivers/staging/Makefile b/drivers/staging/Makefile
index add5e887e451..40dea97d2090 100644
--- a/drivers/staging/Makefile
+++ b/drivers/staging/Makefile
@@ -6,7 +6,6 @@ obj-$(CONFIG_FB_OLPC_DCON)	+= olpc_dcon/
 obj-$(CONFIG_RTL8723BS)		+= rtl8723bs/
 obj-$(CONFIG_R8712U)		+= rtl8712/
 obj-$(CONFIG_OCTEON_ETHERNET)	+= octeon/
-obj-$(CONFIG_VT6656)		+= vt6656/
 obj-$(CONFIG_VME_BUS)		+= vme_user/
 obj-$(CONFIG_IIO)		+= iio/
 obj-$(CONFIG_FB_SM750)		+= sm750fb/
diff --git a/drivers/staging/vt6656/Kconfig b/drivers/staging/vt6656/Kconfig
deleted file mode 100644
index f52a3f1d9a2e..000000000000
--- a/drivers/staging/vt6656/Kconfig
+++ /dev/null
@@ -1,7 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-config VT6656
-	tristate "VIA Technologies VT6656 support"
-	depends on MAC80211 && USB && WLAN && m
-	select FW_LOADER
-	help
-	  This is a vendor-written driver for VIA VT6656.
diff --git a/drivers/staging/vt6656/Makefile b/drivers/staging/vt6656/Makefile
deleted file mode 100644
index f696a9d7a143..000000000000
--- a/drivers/staging/vt6656/Makefile
+++ /dev/null
@@ -1,15 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-
-vt6656_stage-y +=	main_usb.o \
-			card.o  \
-			mac.o   \
-			baseband.o \
-			wcmd.o\
-			rxtx.o \
-			power.o \
-			key.o \
-			rf.o \
-			usbpipe.o \
-			channel.o
-
-obj-$(CONFIG_VT6656) +=	vt6656_stage.o
diff --git a/drivers/staging/vt6656/TODO b/drivers/staging/vt6656/TODO
deleted file mode 100644
index 1edea5e8698b..000000000000
--- a/drivers/staging/vt6656/TODO
+++ /dev/null
@@ -1,17 +0,0 @@
-TODO:
-- remove __cplusplus ifdefs -- done
-- remove kernel version compatibility wrappers
-- remove support for older wireless extensions
-- prepare for merge with vt6655 driver:
-  - remove PRINT_K() macro
-  - split rf.c
-  - abstract VT3184 chipset specific code
-- add common vt665x infrastructure
-- kill ttype.h -- done
-- switch to use MAC80211
-- use kernel coding style
-- sparse fixes
-- integrate with drivers/net/wireless
-
-Please send any patches to Greg Kroah-Hartman <greg@kroah.com>
-and Philipp Hortmann <philipp.g.hortmann@gmail.com>.
diff --git a/drivers/staging/vt6656/baseband.c b/drivers/staging/vt6656/baseband.c
deleted file mode 100644
index ad7b963f0d98..000000000000
--- a/drivers/staging/vt6656/baseband.c
+++ /dev/null
@@ -1,455 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * Purpose: Implement functions to access baseband
- *
- * Author: Jerry Chen
- *
- * Date: Jun. 5, 2002
- *
- * Functions:
- *	vnt_get_frame_time	- Calculate data frame transmitting time
- *	vnt_get_phy_field	- Calculate PhyLength, PhyService and Phy
- *				  Signal parameter for baseband Tx
- *	vnt_vt3184_init		- VIA VT3184 baseband chip init code
- *
- * Revision History:
- *
- *
- */
-
-#include <linux/bits.h>
-#include <linux/errno.h>
-#include <linux/kernel.h>
-#include "device.h"
-#include "mac.h"
-#include "baseband.h"
-#include "rf.h"
-#include "usbpipe.h"
-
-static const u8 vnt_vt3184_agc[] = {
-	0x00, 0x00, 0x02, 0x02, 0x04, 0x04, 0x06, 0x06,
-	0x08, 0x08, 0x0a, 0x0a, 0x0c, 0x0c, 0x0e, 0x0e, /* 0x0f */
-	0x10, 0x10, 0x12, 0x12, 0x14, 0x14, 0x16, 0x16,
-	0x18, 0x18, 0x1a, 0x1a, 0x1c, 0x1c, 0x1e, 0x1e, /* 0x1f */
-	0x20, 0x20, 0x22, 0x22, 0x24, 0x24, 0x26, 0x26,
-	0x28, 0x28, 0x2a, 0x2a, 0x2c, 0x2c, 0x2e, 0x2e, /* 0x2f */
-	0x30, 0x30, 0x32, 0x32, 0x34, 0x34, 0x36, 0x36,
-	0x38, 0x38, 0x3a, 0x3a, 0x3c, 0x3c, 0x3e, 0x3e  /* 0x3f */
-};
-
-static u8 vnt_vt3184_al2230[] = {
-	0x31, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00,
-	0x70, 0x45, 0x2a, 0x76, 0x00, 0x00, 0x80, 0x00, /* 0x0f */
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x8e, 0x0a, 0x00, 0x00, 0x00, /* 0x1f */
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x00, 0x0c, /* 0x2f */
-	0x26, 0x5b, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xaa,
-	0xff, 0xff, 0x79, 0x00, 0x00, 0x0b, 0x48, 0x04, /* 0x3f */
-	0x00, 0x08, 0x00, 0x08, 0x08, 0x14, 0x05, 0x09,
-	0x00, 0x00, 0x00, 0x00, 0x09, 0x73, 0x00, 0xc5, /* 0x4f */
-	0x00, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x5f */
-	0xe4, 0x80, 0x00, 0x00, 0x00, 0x00, 0x98, 0x0a,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x01, 0x00, /* 0x6f */
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x7f */
-	0x8c, 0x01, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x08, 0x00, 0x1f, 0xb7, 0x88, 0x47, 0xaa, 0x00, /* 0x8f */
-	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xeb,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, /* 0x9f */
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
-	0x18, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x18, /* 0xaf */
-	0x38, 0x30, 0x00, 0x00, 0xff, 0x0f, 0xe4, 0xe2,
-	0x00, 0x00, 0x00, 0x03, 0x01, 0x00, 0x00, 0x00, /* 0xbf */
-	0x18, 0x20, 0x07, 0x18, 0xff, 0xff, 0x0e, 0x0a,
-	0x0e, 0x00, 0x82, 0xa7, 0x3c, 0x10, 0x30, 0x05, /* 0xcf */
-	0x40, 0x12, 0x00, 0x00, 0x10, 0x28, 0x80, 0x2a,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0xdf */
-	0x00, 0xf3, 0x00, 0x00, 0x00, 0x10, 0x00, 0x12,
-	0x00, 0xf4, 0x00, 0xff, 0x79, 0x20, 0x30, 0x05, /* 0xef */
-	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* 0xff */
-};
-
-/* {{RobertYu:20060515, new BB setting for VT3226D0 */
-static const u8 vnt_vt3184_vt3226d0[] = {
-	0x31, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00,
-	0x70, 0x45, 0x2a, 0x76, 0x00, 0x00, 0x80, 0x00, /* 0x0f */
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x8e, 0x0a, 0x00, 0x00, 0x00, /* 0x1f */
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x00, 0x0c, /* 0x2f */
-	0x26, 0x5b, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xaa,
-	0xff, 0xff, 0x79, 0x00, 0x00, 0x0b, 0x48, 0x04, /* 0x3f */
-	0x00, 0x08, 0x00, 0x08, 0x08, 0x14, 0x05, 0x09,
-	0x00, 0x00, 0x00, 0x00, 0x09, 0x73, 0x00, 0xc5, /* 0x4f */
-	0x00, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x5f */
-	0xe4, 0x80, 0x00, 0x00, 0x00, 0x00, 0x98, 0x0a,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x01, 0x00, /* 0x6f */
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x7f */
-	0x8c, 0x01, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x08, 0x00, 0x1f, 0xb7, 0x88, 0x47, 0xaa, 0x00, /* 0x8f */
-	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xeb,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, /* 0x9f */
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
-	0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, /* 0xaf */
-	0x38, 0x30, 0x00, 0x00, 0xff, 0x0f, 0xe4, 0xe2,
-	0x00, 0x00, 0x00, 0x03, 0x01, 0x00, 0x00, 0x00, /* 0xbf */
-	0x18, 0x20, 0x07, 0x18, 0xff, 0xff, 0x10, 0x0a,
-	0x0e, 0x00, 0x84, 0xa7, 0x3c, 0x10, 0x24, 0x05, /* 0xcf */
-	0x40, 0x12, 0x00, 0x00, 0x10, 0x28, 0x80, 0x2a,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0xdf */
-	0x00, 0xf3, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10,
-	0x00, 0xf4, 0x00, 0xff, 0x79, 0x20, 0x30, 0x08, /* 0xef */
-	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* 0xff */
-};
-
-struct vnt_threshold {
-	u8 bb_pre_ed_rssi;
-	u8 cr_201;
-	u8 cr_206;
-};
-
-static const struct vnt_threshold al2230_vnt_threshold[] = {
-	{0, 0x00, 0x30},	/* Max sensitivity */
-	{68, 0x00, 0x36},
-	{67, 0x00, 0x43},
-	{66, 0x00, 0x51},
-	{65, 0x00, 0x62},
-	{64, 0x00, 0x79},
-	{63, 0x00, 0x93},
-	{62, 0x00, 0xb9},
-	{61, 0x00, 0xe3},
-	{60, 0x01, 0x18},
-	{59, 0x01, 0x54},
-	{58, 0x01, 0xa0},
-	{57, 0x02, 0x20},
-	{56, 0x02, 0xa0},
-	{55, 0x03, 0x00},
-	{53, 0x06, 0x00},
-	{51, 0x09, 0x00},
-	{49, 0x0e, 0x00},
-	{47, 0x15, 0x00},
-	{46, 0x1a, 0x00},
-	{45, 0xff, 0x00}
-};
-
-static const struct vnt_threshold vt3226_vnt_threshold[] = {
-	{0, 0x00, 0x24},	/* Max sensitivity */
-	{68, 0x00, 0x2d},
-	{67, 0x00, 0x36},
-	{66, 0x00, 0x43},
-	{65, 0x00, 0x52},
-	{64, 0x00, 0x68},
-	{63, 0x00, 0x80},
-	{62, 0x00, 0x9c},
-	{61, 0x00, 0xc0},
-	{60, 0x00, 0xea},
-	{59, 0x01, 0x30},
-	{58, 0x01, 0x70},
-	{57, 0x01, 0xb0},
-	{56, 0x02, 0x30},
-	{55, 0x02, 0xc0},
-	{53, 0x04, 0x00},
-	{51, 0x07, 0x00},
-	{49, 0x0a, 0x00},
-	{47, 0x11, 0x00},
-	{45, 0x18, 0x00},
-	{43, 0x26, 0x00},
-	{42, 0x36, 0x00},
-	{41, 0xff, 0x00}
-};
-
-/*
- * Description: Set Antenna mode
- *
- * Parameters:
- *  In:
- *	priv		- Device Structure
- *	antenna_mode	- Antenna Mode
- *  Out:
- *      none
- *
- * Return Value: none
- *
- */
-int vnt_set_antenna_mode(struct vnt_private *priv, u8 antenna_mode)
-{
-	switch (antenna_mode) {
-	case ANT_TXA:
-	case ANT_TXB:
-		break;
-	case ANT_RXA:
-		priv->bb_rx_conf &= 0xFC;
-		break;
-	case ANT_RXB:
-		priv->bb_rx_conf &= 0xFE;
-		priv->bb_rx_conf |= 0x02;
-		break;
-	}
-
-	return vnt_control_out(priv, MESSAGE_TYPE_SET_ANTMD,
-			       (u16)antenna_mode, 0, 0, NULL);
-}
-
-/*
- * Description: Set Antenna mode
- *
- * Parameters:
- *  In:
- *      pDevice          - Device Structure
- *      byAntennaMode    - Antenna Mode
- *  Out:
- *      none
- *
- * Return Value: none
- *
- */
-
-int vnt_vt3184_init(struct vnt_private *priv)
-{
-	int ret;
-	u16 length;
-	u8 *addr = NULL;
-	const u8 *c_addr;
-	u8 data;
-
-	ret = vnt_control_in(priv, MESSAGE_TYPE_READ, 0, MESSAGE_REQUEST_EEPROM,
-			     EEP_MAX_CONTEXT_SIZE, priv->eeprom);
-	if (ret)
-		goto end;
-
-	priv->rf_type = priv->eeprom[EEP_OFS_RFTYPE];
-
-	dev_dbg(&priv->usb->dev, "RF Type %d\n", priv->rf_type);
-
-	if ((priv->rf_type == RF_AL2230) ||
-	    (priv->rf_type == RF_AL2230S)) {
-		priv->bb_rx_conf = vnt_vt3184_al2230[10];
-		length = sizeof(vnt_vt3184_al2230);
-		addr = vnt_vt3184_al2230;
-
-		priv->bb_vga[0] = 0x1c;
-		priv->bb_vga[1] = 0x10;
-		priv->bb_vga[2] = 0x0;
-		priv->bb_vga[3] = 0x0;
-
-	} else if ((priv->rf_type == RF_VT3226) ||
-		   (priv->rf_type == RF_VT3226D0)) {
-		priv->bb_rx_conf = vnt_vt3184_vt3226d0[10];
-		length = sizeof(vnt_vt3184_vt3226d0);
-		c_addr = vnt_vt3184_vt3226d0;
-
-		priv->bb_vga[0] = 0x20;
-		priv->bb_vga[1] = 0x10;
-		priv->bb_vga[2] = 0x0;
-		priv->bb_vga[3] = 0x0;
-
-		/* Fix VT3226 DFC system timing issue */
-		ret = vnt_mac_reg_bits_on(priv, MAC_REG_SOFTPWRCTL2,
-					  SOFTPWRCTL_RFLEOPT);
-		if (ret)
-			goto end;
-	} else {
-		goto end;
-	}
-
-	if (addr)
-		c_addr = addr;
-
-	ret = vnt_control_out_blocks(priv, VNT_REG_BLOCK_SIZE,
-				     MESSAGE_REQUEST_BBREG, length, c_addr);
-	if (ret)
-		goto end;
-
-	ret = vnt_control_out(priv, MESSAGE_TYPE_WRITE, 0,
-			      MESSAGE_REQUEST_BBAGC,
-			      sizeof(vnt_vt3184_agc), vnt_vt3184_agc);
-	if (ret)
-		goto end;
-
-	if ((priv->rf_type == RF_VT3226) ||
-	    (priv->rf_type == RF_VT3226D0)) {
-		data = (priv->rf_type == RF_VT3226D0) ? 0x11 : 0x23;
-
-		ret = vnt_control_out_u8(priv, MESSAGE_REQUEST_MACREG,
-					 MAC_REG_ITRTMSET, data);
-		if (ret)
-			goto end;
-
-		ret = vnt_mac_reg_bits_on(priv, MAC_REG_PAPEDELAY, BIT(0));
-		if (ret)
-			goto end;
-	}
-
-	ret = vnt_control_out_u8(priv, MESSAGE_REQUEST_BBREG, 0x04, 0x7f);
-	if (ret)
-		goto end;
-
-	ret = vnt_control_out_u8(priv, MESSAGE_REQUEST_BBREG, 0x0d, 0x01);
-	if (ret)
-		goto end;
-
-	ret = vnt_rf_table_download(priv);
-	if (ret)
-		goto end;
-
-	/* Fix for TX USB resets from vendors driver */
-	ret = vnt_control_in(priv, MESSAGE_TYPE_READ, USB_REG4,
-			     MESSAGE_REQUEST_MEM, sizeof(data), &data);
-	if (ret)
-		goto end;
-
-	data |= 0x2;
-
-	ret = vnt_control_out(priv, MESSAGE_TYPE_WRITE, USB_REG4,
-			      MESSAGE_REQUEST_MEM, sizeof(data), &data);
-
-end:
-	return ret;
-}
-
-/*
- * Description: Set ShortSlotTime mode
- *
- * Parameters:
- *  In:
- *	priv	- Device Structure
- *  Out:
- *      none
- *
- * Return Value: none
- *
- */
-int vnt_set_short_slot_time(struct vnt_private *priv)
-{
-	int ret = 0;
-	u8 bb_vga = 0;
-
-	if (priv->short_slot_time)
-		priv->bb_rx_conf &= 0xdf;
-	else
-		priv->bb_rx_conf |= 0x20;
-
-	ret = vnt_control_in_u8(priv, MESSAGE_REQUEST_BBREG, 0xe7, &bb_vga);
-	if (ret)
-		return ret;
-
-	if (bb_vga == priv->bb_vga[0])
-		priv->bb_rx_conf |= 0x20;
-
-	return vnt_control_out_u8(priv, MESSAGE_REQUEST_BBREG, 0x0a,
-				  priv->bb_rx_conf);
-}
-
-int vnt_set_vga_gain_offset(struct vnt_private *priv, u8 data)
-{
-	int ret;
-
-	ret = vnt_control_out_u8(priv, MESSAGE_REQUEST_BBREG, 0xE7, data);
-	if (ret)
-		return ret;
-
-	/* patch for 3253B0 Baseband with Cardbus module */
-	if (priv->short_slot_time)
-		priv->bb_rx_conf &= 0xdf; /* 1101 1111 */
-	else
-		priv->bb_rx_conf |= 0x20; /* 0010 0000 */
-
-	return vnt_control_out_u8(priv, MESSAGE_REQUEST_BBREG, 0x0a,
-				  priv->bb_rx_conf);
-}
-
-/*
- * Description: vnt_set_deep_sleep
- *
- * Parameters:
- *  In:
- *	priv	- Device Structure
- *  Out:
- *      none
- *
- * Return Value: none
- *
- */
-int vnt_set_deep_sleep(struct vnt_private *priv)
-{
-	int ret = 0;
-
-	/* CR12 */
-	ret = vnt_control_out_u8(priv, MESSAGE_REQUEST_BBREG, 0x0c, 0x17);
-	if (ret)
-		return ret;
-
-	/* CR13 */
-	return vnt_control_out_u8(priv, MESSAGE_REQUEST_BBREG, 0x0d, 0xB9);
-}
-
-int vnt_exit_deep_sleep(struct vnt_private *priv)
-{
-	int ret = 0;
-
-	/* CR12 */
-	ret = vnt_control_out_u8(priv, MESSAGE_REQUEST_BBREG, 0x0c, 0x00);
-	if (ret)
-		return ret;
-
-	/* CR13 */
-	return vnt_control_out_u8(priv, MESSAGE_REQUEST_BBREG, 0x0d, 0x01);
-}
-
-int vnt_update_pre_ed_threshold(struct vnt_private *priv, int scanning)
-{
-	const struct vnt_threshold *threshold = NULL;
-	u8 length;
-	u8 cr_201, cr_206;
-	u8 ed_inx;
-	int ret;
-
-	switch (priv->rf_type) {
-	case RF_AL2230:
-	case RF_AL2230S:
-		threshold = al2230_vnt_threshold;
-		length = ARRAY_SIZE(al2230_vnt_threshold);
-		break;
-
-	case RF_VT3226:
-	case RF_VT3226D0:
-		threshold = vt3226_vnt_threshold;
-		length = ARRAY_SIZE(vt3226_vnt_threshold);
-		break;
-	}
-
-	if (!threshold)
-		return -EINVAL;
-
-	for (ed_inx = scanning ? 0 : length - 1; ed_inx > 0; ed_inx--) {
-		if (priv->bb_pre_ed_rssi <= threshold[ed_inx].bb_pre_ed_rssi)
-			break;
-	}
-
-	cr_201 = threshold[ed_inx].cr_201;
-	cr_206 = threshold[ed_inx].cr_206;
-
-	if (ed_inx == priv->bb_pre_ed_index && !scanning)
-		return 0;
-
-	priv->bb_pre_ed_index = ed_inx;
-
-	dev_dbg(&priv->usb->dev, "%s bb_pre_ed_rssi %d\n",
-		__func__, priv->bb_pre_ed_rssi);
-
-	ret = vnt_control_out_u8(priv, MESSAGE_REQUEST_BBREG, 0xc9, cr_201);
-	if (ret)
-		return ret;
-
-	return vnt_control_out_u8(priv, MESSAGE_REQUEST_BBREG, 0xce, cr_206);
-}
-
diff --git a/drivers/staging/vt6656/baseband.h b/drivers/staging/vt6656/baseband.h
deleted file mode 100644
index dce50a311f24..000000000000
--- a/drivers/staging/vt6656/baseband.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * Purpose: Implement functions to access baseband
- *
- * Author: Jerry Chen
- *
- * Date: Jun. 5, 2002
- *
- * Revision History:
- *      06-10-2003 Bryan YC Fan:  Re-write codes to support VT3253 spec.
- *      08-26-2003 Kyle Hsu    :  Add defines of packet type and TX rate.
- */
-
-#ifndef __BASEBAND_H__
-#define __BASEBAND_H__
-
-#include "device.h"
-
-#define PREAMBLE_LONG   0
-#define PREAMBLE_SHORT  1
-
-/*
- * Registers in the BASEBAND
- */
-#define BB_MAX_CONTEXT_SIZE 256
-
-#define C_SIFS_A      16      /* usec */
-#define C_SIFS_BG     10
-
-#define C_EIFS      80      /* usec */
-
-#define C_SLOT_SHORT   9      /* usec */
-#define C_SLOT_LONG   20
-
-#define C_CWMIN_A     15       /* slot time */
-#define C_CWMIN_B     31
-
-#define C_CWMAX      1023     /* slot time */
-
-/* 0:11A 1:11B 2:11G */
-#define BB_TYPE_11A    0
-#define BB_TYPE_11B    1
-#define BB_TYPE_11G    2
-
-/* 0:11a, 1:11b, 2:11gb (only CCK in BasicRate), 3:11ga (OFDM in BasicRate) */
-#define PK_TYPE_11A     0
-#define PK_TYPE_11B     1
-#define PK_TYPE_11GB    2
-#define PK_TYPE_11GA    3
-
-#define TOP_RATE_54M        0x80000000
-#define TOP_RATE_48M        0x40000000
-#define TOP_RATE_36M        0x20000000
-#define TOP_RATE_24M        0x10000000
-#define TOP_RATE_18M        0x08000000
-#define TOP_RATE_12M        0x04000000
-#define TOP_RATE_11M        0x02000000
-#define TOP_RATE_9M         0x01000000
-#define TOP_RATE_6M         0x00800000
-#define TOP_RATE_55M        0x00400000
-#define TOP_RATE_2M         0x00200000
-#define TOP_RATE_1M         0x00100000
-
-int vnt_set_short_slot_time(struct vnt_private *priv);
-int vnt_set_vga_gain_offset(struct vnt_private *priv, u8 data);
-int vnt_set_antenna_mode(struct vnt_private *priv, u8 antenna_mode);
-int vnt_vt3184_init(struct vnt_private *priv);
-int vnt_set_deep_sleep(struct vnt_private *priv);
-int vnt_exit_deep_sleep(struct vnt_private *priv);
-int vnt_update_pre_ed_threshold(struct vnt_private *priv, int scanning);
-
-#endif /* __BASEBAND_H__ */
diff --git a/drivers/staging/vt6656/card.c b/drivers/staging/vt6656/card.c
deleted file mode 100644
index b9dc0d13c00c..000000000000
--- a/drivers/staging/vt6656/card.c
+++ /dev/null
@@ -1,456 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * Purpose: Provide functions to setup NIC operation mode
- * Functions:
- *      vnt_set_rspinf - Set RSPINF
- *      vnt_update_ifs - Update slotTime,SIFS,DIFS, and EIFS
- *      vnt_update_top_rates - Update BasicTopRate
- *      vnt_add_basic_rate - Add to BasicRateSet
- *      vnt_ofdm_min_rate - Check if any OFDM rate is in BasicRateSet
- *      vnt_get_tsf_offset - Calculate TSFOffset
- *      vnt_get_next_tbtt - Calculate Next Beacon TSF counter
- *      vnt_reset_next_tbtt - Set NIC Beacon time
- *      vnt_update_next_tbtt - Sync. NIC Beacon time
- *      vnt_radio_power_off - Turn Off NIC Radio Power
- *      vnt_radio_power_on - Turn On NIC Radio Power
- *
- * Revision History:
- *      06-10-2003 Bryan YC Fan:  Re-write codes to support VT3253 spec.
- *      08-26-2003 Kyle Hsu:      Modify the definition type of dwIoBase.
- *      09-01-2003 Bryan YC Fan:  Add vnt_update_ifs().
- *
- */
-
-#include <linux/bitops.h>
-#include <linux/errno.h>
-#include "device.h"
-#include "card.h"
-#include "baseband.h"
-#include "mac.h"
-#include "desc.h"
-#include "rf.h"
-#include "power.h"
-#include "key.h"
-#include "usbpipe.h"
-
-/* const u16 cw_rxbcntsf_off[MAX_RATE] =
- *   {17, 34, 96, 192, 34, 23, 17, 11, 8, 5, 4, 3};
- */
-
-static const u16 cw_rxbcntsf_off[MAX_RATE] = {
-	192, 96, 34, 17, 34, 23, 17, 11, 8, 5, 4, 3
-};
-
-int vnt_set_channel(struct vnt_private *priv, u32 connection_channel)
-{
-	int ret;
-
-	if (connection_channel > CB_MAX_CHANNEL || !connection_channel)
-		return -EINVAL;
-
-	/* clear NAV */
-	vnt_mac_reg_bits_on(priv, MAC_REG_MACCR, MACCR_CLRNAV);
-
-	/* Set Channel[7] = 0 to tell H/W channel is changing now. */
-	vnt_mac_reg_bits_off(priv, MAC_REG_CHANNEL,
-			     (BIT(7) | BIT(5) | BIT(4)));
-
-	ret = vnt_control_out(priv, MESSAGE_TYPE_SELECT_CHANNEL,
-			      connection_channel, 0, 0, NULL);
-	if (ret)
-		return ret;
-
-	return vnt_control_out_u8(priv, MESSAGE_REQUEST_MACREG, MAC_REG_CHANNEL,
-				  (u8)(connection_channel | 0x80));
-}
-
-static const u8 vnt_rspinf_b_short_table[] = {
-	0x70, 0x00, 0x00, 0x00, 0x38, 0x00, 0x09, 0x00,
-	0x15, 0x00, 0x0a, 0x00, 0x0b, 0x00, 0x0b, 0x80
-};
-
-static const u8 vnt_rspinf_b_long_table[] = {
-	0x70, 0x00, 0x00, 0x00, 0x38, 0x00, 0x01, 0x00,
-	0x15, 0x00, 0x02, 0x00, 0x0b, 0x00, 0x03, 0x80
-};
-
-static const u8 vnt_rspinf_a_table[] = {
-	0x9b, 0x18, 0x9f, 0x10, 0x9a, 0x0a, 0x9e, 0x08, 0x99,
-	0x08, 0x9d, 0x04, 0x98, 0x04, 0x9c, 0x04, 0x9c, 0x04
-};
-
-static const u8 vnt_rspinf_gb_table[] = {
-	0x8b, 0x1e, 0x8f, 0x16, 0x8a, 0x12, 0x8e, 0x0e, 0x89,
-	0x0e, 0x8d, 0x0a, 0x88, 0x0a, 0x8c, 0x0a, 0x8c, 0x0a
-};
-
-int vnt_set_rspinf(struct vnt_private *priv, u8 bb_type)
-{
-	const u8 *data;
-	u16 len;
-	int ret;
-
-	if (priv->preamble_type) {
-		data = vnt_rspinf_b_short_table;
-		len = ARRAY_SIZE(vnt_rspinf_b_short_table);
-	} else {
-		data = vnt_rspinf_b_long_table;
-		len = ARRAY_SIZE(vnt_rspinf_b_long_table);
-	}
-
-	 /* RSPINF_b_1 to RSPINF_b_11 */
-	ret = vnt_control_out(priv, MESSAGE_TYPE_WRITE, MAC_REG_RSPINF_B_1,
-			      MESSAGE_REQUEST_MACREG, len, data);
-	if (ret)
-		return ret;
-
-	if (bb_type == BB_TYPE_11A) {
-		data = vnt_rspinf_a_table;
-		len = ARRAY_SIZE(vnt_rspinf_a_table);
-	} else {
-		data = vnt_rspinf_gb_table;
-		len = ARRAY_SIZE(vnt_rspinf_gb_table);
-	}
-
-	/* RSPINF_a_6 to RSPINF_a_72 */
-	return vnt_control_out(priv, MESSAGE_TYPE_WRITE, MAC_REG_RSPINF_A_6,
-			       MESSAGE_REQUEST_MACREG, len, data);
-}
-
-int vnt_update_ifs(struct vnt_private *priv)
-{
-	u8 max_min = 0;
-	u8 data[4];
-	int ret;
-
-	if (priv->packet_type == PK_TYPE_11A) {
-		priv->slot = C_SLOT_SHORT;
-		priv->sifs = C_SIFS_A;
-		priv->difs = C_SIFS_A + 2 * C_SLOT_SHORT;
-		max_min = 4;
-	} else {
-		priv->sifs = C_SIFS_BG;
-
-		if (priv->short_slot_time) {
-			priv->slot = C_SLOT_SHORT;
-			max_min = 4;
-		} else {
-			priv->slot = C_SLOT_LONG;
-			max_min = 5;
-		}
-
-		priv->difs = C_SIFS_BG + 2 * priv->slot;
-	}
-
-	priv->eifs = C_EIFS;
-
-	data[0] = (u8)priv->sifs;
-	data[1] = (u8)priv->difs;
-	data[2] = (u8)priv->eifs;
-	data[3] = (u8)priv->slot;
-
-	ret = vnt_control_out(priv, MESSAGE_TYPE_WRITE, MAC_REG_SIFS,
-			      MESSAGE_REQUEST_MACREG, 4, &data[0]);
-	if (ret)
-		return ret;
-
-	max_min |= 0xa0;
-
-	return vnt_control_out(priv, MESSAGE_TYPE_WRITE, MAC_REG_CWMAXMIN0,
-			       MESSAGE_REQUEST_MACREG, 1, &max_min);
-}
-
-void vnt_update_top_rates(struct vnt_private *priv)
-{
-	int pos;
-
-	pos = fls(priv->basic_rates & GENMASK(RATE_54M, RATE_6M));
-	priv->top_ofdm_basic_rate = pos ? (pos - 1) : RATE_24M;
-
-	pos = fls(priv->basic_rates & GENMASK(RATE_11M, RATE_1M));
-	priv->top_cck_basic_rate = pos ? (pos - 1) : RATE_1M;
-}
-
-bool vnt_ofdm_min_rate(struct vnt_private *priv)
-{
-	return priv->basic_rates & GENMASK(RATE_54M, RATE_6M) ? true : false;
-}
-
-u8 vnt_get_pkt_type(struct vnt_private *priv)
-{
-	if (priv->bb_type == BB_TYPE_11A || priv->bb_type == BB_TYPE_11B)
-		return (u8)priv->bb_type;
-	else if (vnt_ofdm_min_rate(priv))
-		return PK_TYPE_11GA;
-	return PK_TYPE_11GB;
-}
-
-/*
- * Description: Calculate TSF offset of two TSF input
- *              Get TSF Offset from RxBCN's TSF and local TSF
- *
- * Parameters:
- *  In:
- *      rx_rate	- rx rate.
- *      tsf1	- Rx BCN's TSF
- *      tsf2	- Local TSF
- *  Out:
- *      none
- *
- * Return Value: TSF Offset value
- *
- */
-u64 vnt_get_tsf_offset(u8 rx_rate, u64 tsf1, u64 tsf2)
-{
-	return tsf1 - tsf2 - (u64)cw_rxbcntsf_off[rx_rate % MAX_RATE];
-}
-
-int vnt_adjust_tsf(struct vnt_private *priv, u8 rx_rate,
-		   u64 time_stamp, u64 local_tsf)
-{
-	u64 tsf_offset = 0;
-	u8 data[8];
-
-	tsf_offset = vnt_get_tsf_offset(rx_rate, time_stamp, local_tsf);
-
-	data[0] = (u8)tsf_offset;
-	data[1] = (u8)(tsf_offset >> 8);
-	data[2] = (u8)(tsf_offset >> 16);
-	data[3] = (u8)(tsf_offset >> 24);
-	data[4] = (u8)(tsf_offset >> 32);
-	data[5] = (u8)(tsf_offset >> 40);
-	data[6] = (u8)(tsf_offset >> 48);
-	data[7] = (u8)(tsf_offset >> 56);
-
-	return vnt_control_out(priv, MESSAGE_TYPE_SET_TSFTBTT,
-			       MESSAGE_REQUEST_TSF, 0, 8, data);
-}
-
-/*
- * Description: Clear NIC TSF counter
- *              Clear local TSF counter
- *
- * Parameters:
- *  In:
- *      priv	- The adapter to be read
- *
- * Return Value: true if success; otherwise false
- *
- */
-bool vnt_clear_current_tsf(struct vnt_private *priv)
-{
-	vnt_mac_reg_bits_on(priv, MAC_REG_TFTCTL, TFTCTL_TSFCNTRST);
-
-	priv->current_tsf = 0;
-
-	return true;
-}
-
-/*
- * Description: Read NIC TSF counter
- *              Get NEXTTBTT from adjusted TSF and Beacon Interval
- *
- * Parameters:
- *  In:
- *      tsf		- Current TSF counter
- *      beacon_interval - Beacon Interval
- *  Out:
- *      tsf		- Current TSF counter
- *
- * Return Value: TSF value of next Beacon
- *
- */
-u64 vnt_get_next_tbtt(u64 tsf, u16 beacon_interval)
-{
-	u32 beacon_int;
-
-	beacon_int = beacon_interval * 1024;
-
-	/* Next TBTT =
-	 *	((local_current_TSF / beacon_interval) + 1) * beacon_interval
-	 */
-	if (beacon_int) {
-		do_div(tsf, beacon_int);
-		tsf += 1;
-		tsf *= beacon_int;
-	}
-
-	return tsf;
-}
-
-int vnt_reset_next_tbtt(struct vnt_private *priv, u16 beacon_interval)
-{
-	u64 next_tbtt = 0;
-	u8 data[8];
-
-	vnt_clear_current_tsf(priv);
-
-	next_tbtt = vnt_get_next_tbtt(next_tbtt, beacon_interval);
-
-	data[0] = (u8)next_tbtt;
-	data[1] = (u8)(next_tbtt >> 8);
-	data[2] = (u8)(next_tbtt >> 16);
-	data[3] = (u8)(next_tbtt >> 24);
-	data[4] = (u8)(next_tbtt >> 32);
-	data[5] = (u8)(next_tbtt >> 40);
-	data[6] = (u8)(next_tbtt >> 48);
-	data[7] = (u8)(next_tbtt >> 56);
-
-	return vnt_control_out(priv, MESSAGE_TYPE_SET_TSFTBTT,
-			       MESSAGE_REQUEST_TBTT, 0, 8, data);
-}
-
-int vnt_update_next_tbtt(struct vnt_private *priv, u64 tsf,
-			 u16 beacon_interval)
-{
-	u8 data[8];
-	int ret;
-
-	tsf = vnt_get_next_tbtt(tsf, beacon_interval);
-
-	data[0] = (u8)tsf;
-	data[1] = (u8)(tsf >> 8);
-	data[2] = (u8)(tsf >> 16);
-	data[3] = (u8)(tsf >> 24);
-	data[4] = (u8)(tsf >> 32);
-	data[5] = (u8)(tsf >> 40);
-	data[6] = (u8)(tsf >> 48);
-	data[7] = (u8)(tsf >> 56);
-
-	ret = vnt_control_out(priv, MESSAGE_TYPE_SET_TSFTBTT,
-			      MESSAGE_REQUEST_TBTT, 0, 8, data);
-	if (ret)
-		return ret;
-
-	dev_dbg(&priv->usb->dev, "%s TBTT: %8llx\n", __func__, tsf);
-	return 0;
-}
-
-/*
- * Description: Turn off Radio power
- *
- * Parameters:
- *  In:
- *      priv         - The adapter to be turned off
- *  Out:
- *      none
- *
- * Return Value: true if success; otherwise false
- *
- */
-int vnt_radio_power_off(struct vnt_private *priv)
-{
-	int ret = 0;
-
-	switch (priv->rf_type) {
-	case RF_AL2230:
-	case RF_AL2230S:
-	case RF_VT3226:
-	case RF_VT3226D0:
-		ret = vnt_mac_reg_bits_off(priv, MAC_REG_SOFTPWRCTL,
-					   (SOFTPWRCTL_SWPE2 |
-					    SOFTPWRCTL_SWPE3));
-		break;
-	}
-
-	if (ret)
-		goto end;
-
-	ret = vnt_mac_reg_bits_off(priv, MAC_REG_HOSTCR, HOSTCR_RXON);
-	if (ret)
-		goto end;
-
-	ret = vnt_set_deep_sleep(priv);
-	if (ret)
-		goto end;
-
-	ret = vnt_mac_reg_bits_on(priv, MAC_REG_GPIOCTL1, GPIO3_INTMD);
-
-end:
-	return ret;
-}
-
-/*
- * Description: Turn on Radio power
- *
- * Parameters:
- *  In:
- *      priv         - The adapter to be turned on
- *  Out:
- *      none
- *
- * Return Value: true if success; otherwise false
- *
- */
-int vnt_radio_power_on(struct vnt_private *priv)
-{
-	int ret = 0;
-
-	ret = vnt_exit_deep_sleep(priv);
-	if (ret)
-		return ret;
-
-	ret = vnt_mac_reg_bits_on(priv, MAC_REG_HOSTCR, HOSTCR_RXON);
-	if (ret)
-		return ret;
-
-	switch (priv->rf_type) {
-	case RF_AL2230:
-	case RF_AL2230S:
-	case RF_VT3226:
-	case RF_VT3226D0:
-		ret = vnt_mac_reg_bits_on(priv, MAC_REG_SOFTPWRCTL,
-					  (SOFTPWRCTL_SWPE2 |
-					   SOFTPWRCTL_SWPE3));
-		if (ret)
-			return ret;
-	}
-
-	return vnt_mac_reg_bits_off(priv, MAC_REG_GPIOCTL1, GPIO3_INTMD);
-}
-
-int vnt_set_bss_mode(struct vnt_private *priv)
-{
-	int ret;
-	unsigned char type = priv->bb_type;
-	unsigned char data = 0;
-	unsigned char bb_vga_2_3 = 0x00;
-
-	ret = vnt_mac_set_bb_type(priv, type);
-	if (ret)
-		return ret;
-
-	priv->packet_type = vnt_get_pkt_type(priv);
-
-	if (priv->bb_type == BB_TYPE_11A) {
-		data = 0x03;
-		bb_vga_2_3 = 0x10;
-	} else if (priv->bb_type == BB_TYPE_11B) {
-		data = 0x02;
-	} else if (priv->bb_type == BB_TYPE_11G) {
-		data = 0x08;
-	}
-
-	if (data) {
-		ret = vnt_control_out_u8(priv, MESSAGE_REQUEST_BBREG,
-					 0x88, data);
-		if (ret)
-			return ret;
-	}
-
-	ret = vnt_update_ifs(priv);
-	if (ret)
-		return ret;
-
-	ret = vnt_set_rspinf(priv, priv->bb_type);
-	if (ret)
-		return ret;
-
-	priv->bb_vga[2] = bb_vga_2_3;
-	priv->bb_vga[3] = bb_vga_2_3;
-
-	return vnt_set_vga_gain_offset(priv, priv->bb_vga[0]);
-}
diff --git a/drivers/staging/vt6656/card.h b/drivers/staging/vt6656/card.h
deleted file mode 100644
index eb01f7cc871f..000000000000
--- a/drivers/staging/vt6656/card.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * Purpose: Provide functions to setup NIC operation mode
- *
- * Author: Tevin Chen
- *
- * Date: May 21, 1996
- *
- */
-
-#ifndef __CARD_H__
-#define __CARD_H__
-#include "device.h"
-
-/* init card type */
-
-#define CB_MAX_CHANNEL_24G	14
-#define CB_MAX_CHANNEL_5G	42 /* add channel9(5045MHz), 41==>42 */
-#define CB_MAX_CHANNEL		(CB_MAX_CHANNEL_24G + CB_MAX_CHANNEL_5G)
-
-struct vnt_private;
-
-int vnt_set_channel(struct vnt_private *priv, u32 connection_channel);
-int vnt_set_rspinf(struct vnt_private *priv, u8 bb_type);
-int vnt_update_ifs(struct vnt_private *priv);
-void vnt_update_top_rates(struct vnt_private *priv);
-bool vnt_ofdm_min_rate(struct vnt_private *priv);
-int vnt_adjust_tsf(struct vnt_private *priv, u8 rx_rate,
-		   u64 time_stamp, u64 local_tsf);
-bool vnt_clear_current_tsf(struct vnt_private *priv);
-int vnt_reset_next_tbtt(struct vnt_private *priv, u16 beacon_interval);
-int vnt_update_next_tbtt(struct vnt_private *priv, u64 tsf,
-			 u16 beacon_interval);
-u64 vnt_get_next_tbtt(u64 tsf, u16 beacon_interval);
-u64 vnt_get_tsf_offset(u8 rx_rate, u64 tsf1, u64 tsf2);
-int vnt_radio_power_off(struct vnt_private *priv);
-int vnt_radio_power_on(struct vnt_private *priv);
-u8 vnt_get_pkt_type(struct vnt_private *priv);
-int vnt_set_bss_mode(struct vnt_private *priv);
-
-#endif /* __CARD_H__ */
diff --git a/drivers/staging/vt6656/channel.c b/drivers/staging/vt6656/channel.c
deleted file mode 100644
index 413e2fc4a50d..000000000000
--- a/drivers/staging/vt6656/channel.c
+++ /dev/null
@@ -1,77 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * Purpose: Channel number mapping
- *
- * Author: Lucas Lin
- *
- * Date: Dec 24, 2004
- *
- *
- *
- * Revision History:
- *	01-18-2005	RobertYu:	remove the for loop searching in
- *					ChannelValid, change ChannelRuleTab
- *					to lookup-type, reorder table items.
- *
- *
- */
-
-#include "device.h"
-#include "channel.h"
-#include "rf.h"
-
-static struct ieee80211_rate vnt_rates_bg[] = {
-	{ .bitrate = 10,  .hw_value = RATE_1M },
-	{ .bitrate = 20,  .hw_value = RATE_2M },
-	{ .bitrate = 55,  .hw_value = RATE_5M },
-	{ .bitrate = 110, .hw_value = RATE_11M },
-	{ .bitrate = 60,  .hw_value = RATE_6M },
-	{ .bitrate = 90,  .hw_value = RATE_9M },
-	{ .bitrate = 120, .hw_value = RATE_12M },
-	{ .bitrate = 180, .hw_value = RATE_18M },
-	{ .bitrate = 240, .hw_value = RATE_24M },
-	{ .bitrate = 360, .hw_value = RATE_36M },
-	{ .bitrate = 480, .hw_value = RATE_48M },
-	{ .bitrate = 540, .hw_value = RATE_54M },
-};
-
-static struct ieee80211_channel vnt_channels_2ghz[] = {
-	{ .center_freq = 2412, .hw_value = 1 },
-	{ .center_freq = 2417, .hw_value = 2 },
-	{ .center_freq = 2422, .hw_value = 3 },
-	{ .center_freq = 2427, .hw_value = 4 },
-	{ .center_freq = 2432, .hw_value = 5 },
-	{ .center_freq = 2437, .hw_value = 6 },
-	{ .center_freq = 2442, .hw_value = 7 },
-	{ .center_freq = 2447, .hw_value = 8 },
-	{ .center_freq = 2452, .hw_value = 9 },
-	{ .center_freq = 2457, .hw_value = 10 },
-	{ .center_freq = 2462, .hw_value = 11 },
-	{ .center_freq = 2467, .hw_value = 12 },
-	{ .center_freq = 2472, .hw_value = 13 },
-	{ .center_freq = 2484, .hw_value = 14 }
-};
-
-static struct ieee80211_supported_band vnt_supported_2ghz_band = {
-	.channels = vnt_channels_2ghz,
-	.n_channels = ARRAY_SIZE(vnt_channels_2ghz),
-	.bitrates = vnt_rates_bg,
-	.n_bitrates = ARRAY_SIZE(vnt_rates_bg),
-};
-
-void vnt_init_bands(struct vnt_private *priv)
-{
-	struct ieee80211_channel *ch;
-	int i;
-
-	ch = vnt_channels_2ghz;
-	for (i = 0; i < ARRAY_SIZE(vnt_channels_2ghz); i++) {
-		ch[i].max_power = VNT_RF_MAX_POWER;
-		ch[i].flags = IEEE80211_CHAN_NO_HT40;
-	}
-	priv->hw->wiphy->bands[NL80211_BAND_2GHZ] =
-					&vnt_supported_2ghz_band;
-}
diff --git a/drivers/staging/vt6656/channel.h b/drivers/staging/vt6656/channel.h
deleted file mode 100644
index 723660e40310..000000000000
--- a/drivers/staging/vt6656/channel.h
+++ /dev/null
@@ -1,21 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * Purpose: Country Regulation Rules header file
- *
- * Author: Lucas Lin
- *
- * Date: Dec 23, 2004
- *
- */
-
-#ifndef _CHANNEL_H_
-#define _CHANNEL_H_
-
-#include "device.h"
-
-void vnt_init_bands(struct vnt_private *priv);
-
-#endif  /* _CHANNEL_H_ */
diff --git a/drivers/staging/vt6656/desc.h b/drivers/staging/vt6656/desc.h
deleted file mode 100644
index c13561e528db..000000000000
--- a/drivers/staging/vt6656/desc.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * Purpose:The header file of descriptor
- *
- * Revision History:
- *
- * Author: Tevin Chen
- *
- * Date: May 21, 1996
- *
- */
-
-#ifndef __DESC_H__
-#define __DESC_H__
-
-#include <linux/bits.h>
-#include <linux/types.h>
-#include <linux/mm.h>
-
-/* max transmit or receive buffer size */
-#define CB_MAX_BUF_SIZE     2900U       /* NOTE: must be multiple of 4 */
-
-#define MAX_TOTAL_SIZE_WITH_ALL_HEADERS CB_MAX_BUF_SIZE
-
-#define MAX_INTERRUPT_SIZE              32
-
-#define CB_MAX_RX_DESC      128         /* max # of descriptors */
-#define CB_MIN_RX_DESC      16          /* min # of RX descriptors */
-#define CB_MAX_TX_DESC      128         /* max # of descriptors */
-#define CB_MIN_TX_DESC      16          /* min # of TX descriptors */
-
-/*
- * bits in the RSR register
- */
-#define RSR_ADDRBROAD       BIT(7)
-#define RSR_ADDRMULTI       BIT(6)
-#define RSR_ADDRUNI         0x00
-#define RSR_IVLDTYP         BIT(5)	/* invalid packet type */
-#define RSR_IVLDLEN         BIT(4)	/* invalid len (> 2312 byte) */
-#define RSR_BSSIDOK         BIT(3)
-#define RSR_CRCOK           BIT(2)
-#define RSR_BCNSSIDOK       BIT(1)
-#define RSR_ADDROK          BIT(0)
-
-/*
- * bits in the new RSR register
- */
-#define NEWRSR_DECRYPTOK    BIT(4)
-#define NEWRSR_CFPIND       BIT(3)
-#define NEWRSR_HWUTSF       BIT(2)
-#define NEWRSR_BCNHITAID    BIT(1)
-#define NEWRSR_BCNHITAID0   BIT(0)
-
-/*
- * bits in the TSR register
- */
-#define TSR_RETRYTMO        BIT(3)
-#define TSR_TMO             BIT(2)
-#define TSR_ACKDATA         BIT(1)
-#define TSR_VALID           BIT(0)
-
-#define FIFOCTL_AUTO_FB_1   0x1000
-#define FIFOCTL_AUTO_FB_0   0x0800
-#define FIFOCTL_GRPACK      0x0400
-#define FIFOCTL_11GA        0x0300
-#define FIFOCTL_11GB        0x0200
-#define FIFOCTL_11B         0x0100
-#define FIFOCTL_11A         0x0000
-#define FIFOCTL_RTS         0x0080
-#define FIFOCTL_ISDMA0      0x0040
-#define FIFOCTL_GENINT      0x0020
-#define FIFOCTL_TMOEN       0x0010
-#define FIFOCTL_LRETRY      0x0008
-#define FIFOCTL_CRCDIS      0x0004
-#define FIFOCTL_NEEDACK     0x0002
-#define FIFOCTL_LHEAD       0x0001
-
-/* WMAC definition Frag Control */
-#define FRAGCTL_AES         0x0300
-#define FRAGCTL_TKIP        0x0200
-#define FRAGCTL_LEGACY      0x0100
-#define FRAGCTL_NONENCRYPT  0x0000
-#define FRAGCTL_ENDFRAG     0x0003
-#define FRAGCTL_MIDFRAG     0x0002
-#define FRAGCTL_STAFRAG     0x0001
-#define FRAGCTL_NONFRAG     0x0000
-
-#endif /* __DESC_H__ */
diff --git a/drivers/staging/vt6656/device.h b/drivers/staging/vt6656/device.h
deleted file mode 100644
index ca974d61d3f4..000000000000
--- a/drivers/staging/vt6656/device.h
+++ /dev/null
@@ -1,386 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * Purpose: MAC Data structure
- *
- * Author: Tevin Chen
- *
- * Date: Mar 17, 1997
- *
- */
-
-#ifndef __DEVICE_H__
-#define __DEVICE_H__
-
-#include <linux/bits.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/firmware.h>
-#include <linux/suspend.h>
-#include <linux/if_arp.h>
-#include <linux/wireless.h>
-#include <linux/timer.h>
-#include <linux/usb.h>
-#include <linux/crc32.h>
-#include <net/mac80211.h>
-
-#ifdef SIOCETHTOOL
-#define DEVICE_ETHTOOL_IOCTL_SUPPORT
-#include <linux/ethtool.h>
-#else
-#undef DEVICE_ETHTOOL_IOCTL_SUPPORT
-#endif
-
-#define RATE_1M		0
-#define RATE_2M		1
-#define RATE_5M		2
-#define RATE_11M	3
-#define RATE_6M		4
-#define RATE_9M		5
-#define RATE_12M	6
-#define RATE_18M	7
-#define RATE_24M	8
-#define RATE_36M	9
-#define RATE_48M	10
-#define RATE_54M	11
-#define RATE_AUTO	12
-
-#define MAX_RATE			12
-#define VNT_B_RATES	(BIT(RATE_1M) | BIT(RATE_2M) |\
-			BIT(RATE_5M) | BIT(RATE_11M))
-
-/*
- * device specific
- */
-
-#include "wcmd.h"
-#include "desc.h"
-#include "key.h"
-#include "card.h"
-
-#define VNT_USB_VENDOR_ID                     0x160a
-#define VNT_USB_PRODUCT_ID                    0x3184
-
-#define DEVICE_NAME			"vt6656"
-#define DEVICE_FULL_DRV_NAM		"VIA Networking Wireless LAN USB Driver"
-
-#define DEVICE_VERSION			"mac80211"
-
-#define FIRMWARE_VERSION		0x133		/* version 1.51 */
-#define FIRMWARE_NAME			"vntwusb.fw"
-#define FIRMWARE_CHUNK_SIZE		0x400
-
-#define MAX_UINTS			8
-#define OPTION_DEFAULT			{ [0 ... MAX_UINTS - 1] = -1}
-
-#define DUPLICATE_RX_CACHE_LENGTH       5
-
-#define AUTO_FB_NONE            0
-#define AUTO_FB_0               1
-#define AUTO_FB_1               2
-
-#define FB_RATE0                0
-#define FB_RATE1                1
-
-/* Antenna Mode */
-#define ANT_A                   0
-#define ANT_B                   1
-#define ANT_DIVERSITY           2
-#define ANT_RXD_TXA             3
-#define ANT_RXD_TXB             4
-#define ANT_UNKNOWN             0xFF
-#define ANT_TXA                 0
-#define ANT_TXB                 1
-#define ANT_RXA                 2
-#define ANT_RXB                 3
-
-#define BB_VGA_LEVEL            4
-#define BB_VGA_CHANGE_THRESHOLD 3
-
-#define EEP_MAX_CONTEXT_SIZE    256
-
-/* Contents in the EEPROM */
-#define EEP_OFS_PAR		0x0
-#define EEP_OFS_ANTENNA		0x17
-#define EEP_OFS_RADIOCTL	0x18
-#define EEP_OFS_RFTYPE		0x1b
-#define EEP_OFS_MINCHANNEL	0x1c
-#define EEP_OFS_MAXCHANNEL	0x1d
-#define EEP_OFS_SIGNATURE	0x1e
-#define EEP_OFS_ZONETYPE	0x1f
-#define EEP_OFS_RFTABLE		0x20
-#define EEP_OFS_PWR_CCK		0x20
-#define EEP_OFS_SETPT_CCK	0x21
-#define EEP_OFS_PWR_OFDMG	0x23
-
-#define EEP_OFS_CALIB_TX_IQ	0x24
-#define EEP_OFS_CALIB_TX_DC	0x25
-#define EEP_OFS_CALIB_RX_IQ	0x26
-
-#define EEP_OFS_MAJOR_VER	0x2e
-#define EEP_OFS_MINOR_VER	0x2f
-
-#define EEP_OFS_CCK_PWR_TBL	0x30
-#define EEP_OFS_OFDM_PWR_TBL	0x40
-#define EEP_OFS_OFDMA_PWR_TBL	0x50
-
-/* Bits in EEP_OFS_ANTENNA */
-#define EEP_ANTENNA_MAIN	BIT(0)
-#define EEP_ANTENNA_AUX		BIT(1)
-#define EEP_ANTINV		BIT(2)
-
-/* Bits in EEP_OFS_RADIOCTL */
-#define EEP_RADIOCTL_ENABLE	BIT(7)
-
-/* control commands */
-#define MESSAGE_TYPE_READ		0x1
-#define MESSAGE_TYPE_WRITE		0x0
-#define MESSAGE_TYPE_LOCK_OR		0x2
-#define MESSAGE_TYPE_LOCK_AND		0x3
-#define MESSAGE_TYPE_WRITE_MASK		0x4
-#define MESSAGE_TYPE_CARDINIT		0x5
-#define MESSAGE_TYPE_INIT_RSP		0x6
-#define MESSAGE_TYPE_MACSHUTDOWN	0x7
-#define MESSAGE_TYPE_SETKEY		0x8
-#define MESSAGE_TYPE_CLRKEYENTRY	0x9
-#define MESSAGE_TYPE_WRITE_MISCFF	0xa
-#define MESSAGE_TYPE_SET_ANTMD		0xb
-#define MESSAGE_TYPE_SELECT_CHANNEL	0xc
-#define MESSAGE_TYPE_SET_TSFTBTT	0xd
-#define MESSAGE_TYPE_SET_SSTIFS		0xe
-#define MESSAGE_TYPE_CHANGE_BBTYPE	0xf
-#define MESSAGE_TYPE_DISABLE_PS		0x10
-#define MESSAGE_TYPE_WRITE_IFRF		0x11
-
-/* command read/write(index) */
-#define MESSAGE_REQUEST_MEM		0x1
-#define MESSAGE_REQUEST_BBREG		0x2
-#define MESSAGE_REQUEST_MACREG		0x3
-#define MESSAGE_REQUEST_EEPROM		0x4
-#define MESSAGE_REQUEST_TSF		0x5
-#define MESSAGE_REQUEST_TBTT		0x6
-#define MESSAGE_REQUEST_BBAGC		0x7
-#define MESSAGE_REQUEST_VERSION		0x8
-#define MESSAGE_REQUEST_RF_INIT		0x9
-#define MESSAGE_REQUEST_RF_INIT2	0xa
-#define MESSAGE_REQUEST_RF_CH0		0xb
-#define MESSAGE_REQUEST_RF_CH1		0xc
-#define MESSAGE_REQUEST_RF_CH2		0xd
-
-/* USB registers */
-#define USB_REG4			0x604
-
-#define DEVICE_INIT_COLD	0x0 /* cold init */
-#define DEVICE_INIT_RESET	0x1 /* reset init or Dx to D0 power remain */
-#define DEVICE_INIT_DXPL	0x2 /* Dx to D0 power lost init */
-
-/* Device init */
-struct vnt_cmd_card_init {
-	u8 init_class;
-	u8 exist_sw_net_addr;
-	u8 sw_net_addr[6];
-	u8 short_retry_limit;
-	u8 long_retry_limit;
-};
-
-struct vnt_rsp_card_init {
-	u8 status;
-	u8 net_addr[6];
-	u8 rf_type;
-	u8 min_channel;
-	u8 max_channel;
-};
-
-/* USB */
-
-/*
- * Enum of context types for SendPacket
- */
-enum {
-	CONTEXT_DATA_PACKET = 0,
-	CONTEXT_BEACON_PACKET
-};
-
-struct vnt_rx_header {
-	u32 wbk_status;
-	u8 rx_sts;
-	u8 rx_rate;
-	u16 pay_load_len;
-} __packed;
-
-struct vnt_rx_tail {
-	__le64 tsf_time;
-	u8 sq;
-	u8 new_rsr;
-	u8 rssi;
-	u8 rsr;
-	u8 sq_3;
-} __packed;
-
-/* RCB (Receive Control Block) */
-struct vnt_rcb {
-	void *priv;
-	struct urb *urb;
-	struct sk_buff *skb;
-};
-
-/* used to track bulk out irps */
-struct vnt_usb_send_context {
-	void *priv;
-	struct sk_buff *skb;
-	void *tx_buffer;
-	u32 frame_len;
-	u16 tx_hdr_size;
-	u16 tx_rate;
-	u8 type;
-	u8 pkt_no;
-	u8 pkt_type;
-	bool in_use;
-};
-
-/*
- * Structure to keep track of USB interrupt packets
- */
-struct vnt_interrupt_buffer {
-	u8 *data_buf;
-};
-
-/* flags for options */
-#define DEVICE_FLAGS_UNPLUG		0
-#define DEVICE_FLAGS_DISCONNECTED	1
-
-struct vnt_private {
-	/* mac80211 */
-	struct ieee80211_hw *hw;
-	struct ieee80211_vif *vif;
-	u8 mac_hw;
-	/* netdev */
-	struct usb_device *usb;
-	struct usb_interface *intf;
-
-	u64 tsf_time;
-
-	u32 rx_buf_sz;
-	int mc_list_count;
-
-	spinlock_t lock;		/* prepare tx USB URB */
-	struct mutex usb_lock;		/* USB control messages */
-
-	unsigned long flags;
-
-	/* USB */
-	struct urb *interrupt_urb;
-	u32 int_interval;
-
-	/* Variables to track resources for the BULK In Pipe */
-	struct vnt_rcb *rcb[CB_MAX_RX_DESC];
-	u32 num_rcb;
-
-	/* Variables to track resources for the BULK Out Pipe */
-	struct vnt_usb_send_context *tx_context[CB_MAX_TX_DESC];
-	struct usb_anchor tx_submitted;
-	u32 num_tx_context;
-
-	/* Variables to track resources for the Interrupt In Pipe */
-	struct vnt_interrupt_buffer int_buf;
-
-	/* Version control */
-	u16 firmware_version;
-	u8 local_id;
-	u8 rf_type;
-	u8 bb_rx_conf;
-
-	struct vnt_cmd_card_init init_command;
-	struct vnt_rsp_card_init init_response;
-	u8 current_net_addr[ETH_ALEN] __aligned(2);
-	u8 permanent_net_addr[ETH_ALEN] __aligned(2);
-
-	u8 exist_sw_net_addr;
-
-	u64 current_tsf;
-
-	/* 802.11 MAC specific */
-	u32 current_rssi;
-
-	/* Antenna Diversity */
-	int tx_rx_ant_inv;
-	u32 rx_antenna_sel;
-	u8 rx_antenna_mode;
-	u8 tx_antenna_mode;
-	u8 radio_ctl;
-
-	/* IFS & Cw */
-	u32 sifs;  /* Current SIFS */
-	u32 difs;  /* Current DIFS */
-	u32 eifs;  /* Current EIFS */
-	u32 slot;  /* Current SlotTime */
-
-	/* Rate */
-	u8 bb_type; /* 0: 11A, 1:11B, 2:11G */
-	u8 packet_type; /* 0:11a 1:11b 2:11gb 3:11ga */
-	u32 basic_rates;
-	u8 top_ofdm_basic_rate;
-	u8 top_cck_basic_rate;
-
-	u8 eeprom[EEP_MAX_CONTEXT_SIZE];  /*u32 alignment */
-
-	u8 preamble_type;
-
-	/* For RF Power table */
-	u8 cck_pwr;
-	u8 ofdm_pwr_g;
-	u8 ofdm_pwr_a;
-	u8 power;
-	u8 cck_pwr_tbl[14];
-	u8 ofdm_pwr_tbl[14];
-	u8 ofdm_a_pwr_tbl[42];
-
-	u16 tx_rate_fb0;
-	u16 tx_rate_fb1;
-
-	enum nl80211_iftype op_mode;
-
-	int short_slot_time;
-
-	/* Power save */
-	u16 current_aid;
-
-	/* Beacon related */
-	u16 seq_counter;
-
-	enum vnt_cmd_state command_state;
-
-	enum vnt_cmd command;
-
-	/* 802.11 counter */
-
-	enum vnt_cmd cmd_queue[CMD_Q_SIZE];
-	u32 cmd_dequeue_idx;
-	u32 cmd_enqueue_idx;
-	u32 free_cmd_queue;
-	int cmd_running;
-
-	unsigned long key_entry_inuse;
-
-	u8 auto_fb_ctrl;
-
-	/* For Update BaseBand VGA Gain Offset */
-	u8 bb_vga[BB_VGA_LEVEL];
-
-	u8 bb_pre_ed_rssi;
-	u8 bb_pre_ed_index;
-
-	/* command timer */
-	struct delayed_work run_command_work;
-
-	struct ieee80211_low_level_stats low_stats;
-};
-
-int vnt_init(struct vnt_private *priv);
-
-#endif
diff --git a/drivers/staging/vt6656/key.c b/drivers/staging/vt6656/key.c
deleted file mode 100644
index bdc5f30c4f9d..000000000000
--- a/drivers/staging/vt6656/key.c
+++ /dev/null
@@ -1,142 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * Purpose: Implement functions for 802.11i Key management
- *
- * Author: Jerry Chen
- *
- * Date: May 29, 2003
- *
- * Functions:
- *
- * Revision History:
- *
- */
-
-#include "mac.h"
-#include "key.h"
-#include "usbpipe.h"
-
-int vnt_key_init_table(struct vnt_private *priv)
-{
-	u8 i;
-	u8 data[MAX_KEY_TABLE];
-
-	for (i = 0; i < MAX_KEY_TABLE; i++)
-		data[i] = i;
-
-	return vnt_control_out(priv, MESSAGE_TYPE_CLRKEYENTRY,
-			0, 0, ARRAY_SIZE(data), data);
-}
-
-static int vnt_set_keymode(struct ieee80211_hw *hw, u8 *mac_addr,
-			   struct ieee80211_key_conf *key, u32 key_type,
-			   u32 mode)
-{
-	struct vnt_private *priv = hw->priv;
-	u8 broadcast[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-	u16 key_mode = 0;
-	u32 entry = 0;
-	u8 *bssid;
-	u8 key_inx = key->keyidx;
-	u8 i;
-
-	if (mac_addr)
-		bssid = mac_addr;
-	else
-		bssid = &broadcast[0];
-
-	if (key_type != VNT_KEY_DEFAULTKEY) {
-		for (i = 0; i < (MAX_KEY_TABLE - 1); i++) {
-			if (!test_bit(i, &priv->key_entry_inuse)) {
-				set_bit(i, &priv->key_entry_inuse);
-
-				key->hw_key_idx = i;
-				entry = key->hw_key_idx;
-				break;
-			}
-		}
-	}
-
-	switch (key_type) {
-	case VNT_KEY_DEFAULTKEY:
-		/* default key last entry */
-		entry = MAX_KEY_TABLE - 1;
-		key->hw_key_idx = entry;
-		fallthrough;
-	case VNT_KEY_GROUP_ADDRESS:
-		key_mode = mode | (mode << 4);
-		break;
-	case VNT_KEY_GROUP:
-		key_mode = mode << 4;
-		break;
-	case  VNT_KEY_PAIRWISE:
-		key_mode |= mode;
-		key_inx = 4;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	key_mode |= key_type;
-
-	if (mode == KEY_CTL_WEP) {
-		if (key->keylen == WLAN_KEY_LEN_WEP40)
-			key->key[15] &= 0x7f;
-		if (key->keylen == WLAN_KEY_LEN_WEP104)
-			key->key[15] |= 0x80;
-	}
-
-	return vnt_mac_set_keyentry(priv, key_mode, entry,
-				    key_inx, bssid, key->key);
-}
-
-int vnt_set_keys(struct ieee80211_hw *hw, struct ieee80211_sta *sta,
-		 struct ieee80211_vif *vif, struct ieee80211_key_conf *key)
-{
-	struct vnt_private *priv = hw->priv;
-	u8 *mac_addr = NULL;
-	u8 key_dec_mode = 0;
-
-	if (sta)
-		mac_addr = &sta->addr[0];
-
-	switch (key->cipher) {
-	case WLAN_CIPHER_SUITE_WEP40:
-	case WLAN_CIPHER_SUITE_WEP104:
-		vnt_set_keymode(hw, mac_addr, key, VNT_KEY_DEFAULTKEY,
-				KEY_CTL_WEP);
-
-		key->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;
-
-		return vnt_set_keymode(hw, mac_addr, key, VNT_KEY_DEFAULTKEY,
-				       KEY_CTL_WEP);
-
-	case WLAN_CIPHER_SUITE_TKIP:
-		key->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;
-		key->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;
-
-		key_dec_mode = KEY_CTL_TKIP;
-
-		break;
-	case WLAN_CIPHER_SUITE_CCMP:
-		if (priv->local_id <= MAC_REVISION_A1)
-			return -EOPNOTSUPP;
-
-		key_dec_mode = KEY_CTL_CCMP;
-
-		key->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;
-		break;
-	default:
-		return -EOPNOTSUPP;
-	}
-
-	if (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)
-		return vnt_set_keymode(hw, mac_addr, key, VNT_KEY_PAIRWISE,
-				       key_dec_mode);
-
-	return vnt_set_keymode(hw, mac_addr, key,
-				VNT_KEY_GROUP_ADDRESS, key_dec_mode);
-}
diff --git a/drivers/staging/vt6656/key.h b/drivers/staging/vt6656/key.h
deleted file mode 100644
index 6f1d5b4f6da7..000000000000
--- a/drivers/staging/vt6656/key.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * Purpose: Implement functions for 802.11i Key management
- *
- * Author: Jerry Chen
- *
- * Date: May 29, 2003
- *
- */
-
-#ifndef __KEY_H__
-#define __KEY_H__
-
-#include "device.h"
-
-#define MAX_KEY_TABLE       11
-
-#define KEY_CTL_WEP         0x00
-#define KEY_CTL_NONE        0x01
-#define KEY_CTL_TKIP        0x02
-#define KEY_CTL_CCMP        0x03
-
-#define VNT_KEY_ONFLY_ALL	0x4000
-#define VNT_KEY_ONFLY		0x8000
-#define VNT_KEY_ALLGROUP	0x04
-#define VNT_KEY_GROUP		0x40
-#define VNT_KEY_PAIRWISE	VNT_KEY_ONFLY
-#define VNT_KEY_GROUP_ADDRESS	(VNT_KEY_ALLGROUP | VNT_KEY_GROUP)
-#define VNT_KEY_DEFAULTKEY	(VNT_KEY_GROUP_ADDRESS | VNT_KEY_ONFLY |\
-				VNT_KEY_ONFLY_ALL)
-
-int vnt_key_init_table(struct vnt_private *priv);
-
-int vnt_set_keys(struct ieee80211_hw *hw, struct ieee80211_sta *sta,
-		 struct ieee80211_vif *vif, struct ieee80211_key_conf *key);
-
-#endif /* __KEY_H__ */
diff --git a/drivers/staging/vt6656/mac.c b/drivers/staging/vt6656/mac.c
deleted file mode 100644
index 49430c0a99b8..000000000000
--- a/drivers/staging/vt6656/mac.c
+++ /dev/null
@@ -1,183 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * Purpose:  MAC routines
- *
- * Author: Tevin Chen
- *
- * Date: May 21, 1996
- *
- * Functions:
- *
- * Revision History:
- */
-
-#include <linux/etherdevice.h>
-
-#include "desc.h"
-#include "mac.h"
-#include "usbpipe.h"
-
-int vnt_mac_set_filter(struct vnt_private *priv, u64 mc_filter)
-{
-	__le64 le_mc = cpu_to_le64(mc_filter);
-
-	return vnt_control_out(priv, MESSAGE_TYPE_WRITE, MAC_REG_MAR0,
-			       MESSAGE_REQUEST_MACREG, sizeof(le_mc),
-			       (u8 *)&le_mc);
-}
-
-int vnt_mac_shutdown(struct vnt_private *priv)
-{
-	return vnt_control_out(priv, MESSAGE_TYPE_MACSHUTDOWN, 0, 0, 0, NULL);
-}
-
-int vnt_mac_set_bb_type(struct vnt_private *priv, u8 type)
-{
-	u8 data[2];
-
-	data[0] = type;
-	data[1] = EN_CFG_BB_TYPE_MASK;
-
-	return vnt_control_out(priv, MESSAGE_TYPE_WRITE_MASK, MAC_REG_ENCFG0,
-			       MESSAGE_REQUEST_MACREG,	ARRAY_SIZE(data),
-			       data);
-}
-
-int vnt_mac_disable_keyentry(struct vnt_private *priv, u8 entry_idx)
-{
-	return vnt_control_out(priv, MESSAGE_TYPE_CLRKEYENTRY, 0, 0,
-			       sizeof(entry_idx), &entry_idx);
-}
-
-int vnt_mac_set_keyentry(struct vnt_private *priv, u16 key_ctl, u32 entry_idx,
-			 u32 key_idx, u8 *addr, u8 *key)
-{
-	struct vnt_mac_set_key set_key;
-	u16 offset;
-
-	offset = MISCFIFO_KEYETRY0;
-	offset += entry_idx * MISCFIFO_KEYENTRYSIZE;
-
-	set_key.u.write.key_ctl = cpu_to_le16(key_ctl);
-	ether_addr_copy(set_key.u.write.addr, addr);
-
-	/* swap over swap[0] and swap[1] to get correct write order */
-	swap(set_key.u.swap[0], set_key.u.swap[1]);
-
-	memcpy(set_key.key, key, WLAN_KEY_LEN_CCMP);
-
-	dev_dbg(&priv->usb->dev, "offset %d key ctl %d set key %24ph\n",
-		offset, key_ctl, (u8 *)&set_key);
-
-	return vnt_control_out(priv, MESSAGE_TYPE_SETKEY, offset,
-			       (u16)key_idx, sizeof(struct vnt_mac_set_key),
-			       (u8 *)&set_key);
-}
-
-int vnt_mac_reg_bits_off(struct vnt_private *priv, u8 reg_ofs, u8 bits)
-{
-	u8 data[2];
-
-	data[0] = 0;
-	data[1] = bits;
-
-	return vnt_control_out(priv, MESSAGE_TYPE_WRITE_MASK, reg_ofs,
-			       MESSAGE_REQUEST_MACREG, ARRAY_SIZE(data), data);
-}
-
-int vnt_mac_reg_bits_on(struct vnt_private *priv, u8 reg_ofs, u8 bits)
-{
-	u8 data[2];
-
-	data[0] = bits;
-	data[1] = bits;
-
-	return vnt_control_out(priv, MESSAGE_TYPE_WRITE_MASK, reg_ofs,
-			       MESSAGE_REQUEST_MACREG, ARRAY_SIZE(data), data);
-}
-
-int vnt_mac_write_word(struct vnt_private *priv, u8 reg_ofs, u16 word)
-{
-	u8 data[2];
-
-	data[0] = (u8)(word & 0xff);
-	data[1] = (u8)(word >> 8);
-
-	return vnt_control_out(priv, MESSAGE_TYPE_WRITE, reg_ofs,
-			       MESSAGE_REQUEST_MACREG, ARRAY_SIZE(data), data);
-}
-
-int vnt_mac_set_bssid_addr(struct vnt_private *priv, u8 *addr)
-{
-	return vnt_control_out(priv, MESSAGE_TYPE_WRITE, MAC_REG_BSSID0,
-			       MESSAGE_REQUEST_MACREG, ETH_ALEN, addr);
-}
-
-int vnt_mac_enable_protect_mode(struct vnt_private *priv)
-{
-	u8 data[2];
-
-	data[0] = EN_CFG_PROTECT_MD;
-	data[1] = EN_CFG_PROTECT_MD;
-
-	return vnt_control_out(priv, MESSAGE_TYPE_WRITE_MASK, MAC_REG_ENCFG0,
-			       MESSAGE_REQUEST_MACREG, ARRAY_SIZE(data), data);
-}
-
-int vnt_mac_disable_protect_mode(struct vnt_private *priv)
-{
-	u8 data[2];
-
-	data[0] = 0;
-	data[1] = EN_CFG_PROTECT_MD;
-
-	return vnt_control_out(priv, MESSAGE_TYPE_WRITE_MASK, MAC_REG_ENCFG0,
-			       MESSAGE_REQUEST_MACREG, ARRAY_SIZE(data), data);
-}
-
-int vnt_mac_enable_barker_preamble_mode(struct vnt_private *priv)
-{
-	u8 data[2];
-
-	data[0] = EN_CFG_BARKER_PREAM;
-	data[1] = EN_CFG_BARKER_PREAM;
-
-	return vnt_control_out(priv, MESSAGE_TYPE_WRITE_MASK, MAC_REG_ENCFG2,
-			       MESSAGE_REQUEST_MACREG, ARRAY_SIZE(data), data);
-}
-
-int vnt_mac_disable_barker_preamble_mode(struct vnt_private *priv)
-{
-	u8 data[2];
-
-	data[0] = 0;
-	data[1] = EN_CFG_BARKER_PREAM;
-
-	return vnt_control_out(priv, MESSAGE_TYPE_WRITE_MASK, MAC_REG_ENCFG2,
-			       MESSAGE_REQUEST_MACREG, ARRAY_SIZE(data), data);
-}
-
-int vnt_mac_set_beacon_interval(struct vnt_private *priv, u16 interval)
-{
-	u8 data[2];
-
-	data[0] = (u8)(interval & 0xff);
-	data[1] = (u8)(interval >> 8);
-
-	return vnt_control_out(priv, MESSAGE_TYPE_WRITE, MAC_REG_BI,
-			       MESSAGE_REQUEST_MACREG, ARRAY_SIZE(data), data);
-}
-
-int vnt_mac_set_led(struct vnt_private *priv, u8 state, u8 led)
-{
-	u8 data[2];
-
-	data[0] = led;
-	data[1] = state;
-
-	return vnt_control_out(priv, MESSAGE_TYPE_WRITE_MASK, MAC_REG_PAPEDELAY,
-			       MESSAGE_REQUEST_MACREG, ARRAY_SIZE(data), data);
-}
diff --git a/drivers/staging/vt6656/mac.h b/drivers/staging/vt6656/mac.h
deleted file mode 100644
index 0ac845bd3c5a..000000000000
--- a/drivers/staging/vt6656/mac.h
+++ /dev/null
@@ -1,373 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * Purpose: MAC routines
- *
- * Author: Tevin Chen
- *
- * Date: May 21, 1996
- *
- * Revision History:
- *      07-01-2003 Bryan YC Fan:  Re-write codes to support VT3253 spec.
- *      08-25-2003 Kyle Hsu:      Porting MAC functions from sim53.
- *      09-03-2003 Bryan YC Fan:  Add MACvDisableProtectMD & MACvEnableProtectMD
- */
-
-#ifndef __MAC_H__
-#define __MAC_H__
-
-#include <linux/bits.h>
-#include "device.h"
-
-#define REV_ID_VT3253_A0	0x00
-#define REV_ID_VT3253_A1	0x01
-#define REV_ID_VT3253_B0	0x08
-#define REV_ID_VT3253_B1	0x09
-
-/* Registers in the MAC */
-#define MAC_REG_BISTCMD		0x04
-#define MAC_REG_BISTSR0		0x05
-#define MAC_REG_BISTSR1		0x06
-#define MAC_REG_BISTSR2		0x07
-#define MAC_REG_I2MCSR		0x08
-#define MAC_REG_I2MTGID		0x09
-#define MAC_REG_I2MTGAD		0x0a
-#define MAC_REG_I2MCFG		0x0b
-#define MAC_REG_I2MDIPT		0x0c
-#define MAC_REG_I2MDOPT		0x0e
-#define MAC_REG_USBSUS		0x0f
-
-#define MAC_REG_LOCALID		0x14
-#define MAC_REG_TESTCFG		0x15
-#define MAC_REG_JUMPER0		0x16
-#define MAC_REG_JUMPER1		0x17
-#define MAC_REG_TMCTL		0x18
-#define MAC_REG_TMDATA0		0x1c
-#define MAC_REG_TMDATA1		0x1d
-#define MAC_REG_TMDATA2		0x1e
-#define MAC_REG_TMDATA3		0x1f
-
-/* MAC Parameter related */
-#define MAC_REG_LRT		0x20
-#define MAC_REG_SRT		0x21
-#define MAC_REG_SIFS		0x22
-#define MAC_REG_DIFS		0x23
-#define MAC_REG_EIFS		0x24
-#define MAC_REG_SLOT		0x25
-#define MAC_REG_BI		0x26
-#define MAC_REG_CWMAXMIN0	0x28
-#define MAC_REG_LINKOFFTOTM	0x2a
-#define MAC_REG_SWTMOT		0x2b
-#define MAC_REG_RTSOKCNT	0x2c
-#define MAC_REG_RTSFAILCNT	0x2d
-#define MAC_REG_ACKFAILCNT	0x2e
-#define MAC_REG_FCSERRCNT	0x2f
-
-/* TSF Related */
-#define MAC_REG_TSFCNTR		0x30
-#define MAC_REG_NEXTTBTT	0x38
-#define MAC_REG_TSFOFST		0x40
-#define MAC_REG_TFTCTL		0x48
-
-/* WMAC Control/Status Related */
-#define MAC_REG_ENCFG0		0x4c
-#define MAC_REG_ENCFG1		0x4d
-#define MAC_REG_ENCFG2		0x4e
-
-#define MAC_REG_CFG		0x50
-#define MAC_REG_TEST		0x52
-#define MAC_REG_HOSTCR		0x54
-#define MAC_REG_MACCR		0x55
-#define MAC_REG_RCR		0x56
-#define MAC_REG_TCR		0x57
-#define MAC_REG_IMR		0x58
-#define MAC_REG_ISR		0x5c
-#define MAC_REG_ISR1		0x5d
-
-/* Power Saving Related */
-#define MAC_REG_PSCFG		0x60
-#define MAC_REG_PSCTL		0x61
-#define MAC_REG_PSPWRSIG	0x62
-#define MAC_REG_BBCR13		0x63
-#define MAC_REG_AIDATIM		0x64
-#define MAC_REG_PWBT		0x66
-#define MAC_REG_WAKEOKTMR	0x68
-#define MAC_REG_CALTMR		0x69
-#define MAC_REG_SYNSPACCNT	0x6a
-#define MAC_REG_WAKSYNOPT	0x6b
-
-/* Baseband/IF Control Group */
-#define MAC_REG_BBREGCTL	0x6c
-#define MAC_REG_CHANNEL		0x6d
-#define MAC_REG_BBREGADR	0x6e
-#define MAC_REG_BBREGDATA	0x6f
-#define MAC_REG_IFREGCTL	0x70
-#define MAC_REG_IFDATA		0x71
-#define MAC_REG_ITRTMSET	0x74
-#define MAC_REG_PAPEDELAY	0x77
-#define MAC_REG_SOFTPWRCTL	0x78
-#define MAC_REG_SOFTPWRCTL2	0x79
-#define MAC_REG_GPIOCTL0	0x7a
-#define MAC_REG_GPIOCTL1	0x7b
-
-/* MiscFF PIO related */
-#define MAC_REG_MISCFFNDEX	0xbc
-#define MAC_REG_MISCFFCTL	0xbe
-#define MAC_REG_MISCFFDATA	0xc0
-
-/* MAC Configuration Group */
-#define MAC_REG_PAR0		0xc4
-#define MAC_REG_PAR4		0xc8
-#define MAC_REG_BSSID0		0xcc
-#define MAC_REG_BSSID4		0xd0
-#define MAC_REG_MAR0		0xd4
-#define MAC_REG_MAR4		0xd8
-
-/* MAC RSPPKT INFO Group */
-#define MAC_REG_RSPINF_B_1	0xdC
-#define MAC_REG_RSPINF_B_2	0xe0
-#define MAC_REG_RSPINF_B_5	0xe4
-#define MAC_REG_RSPINF_B_11	0xe8
-#define MAC_REG_RSPINF_A_6	0xec
-#define MAC_REG_RSPINF_A_9	0xee
-#define MAC_REG_RSPINF_A_12	0xf0
-#define MAC_REG_RSPINF_A_18	0xf2
-#define MAC_REG_RSPINF_A_24	0xf4
-#define MAC_REG_RSPINF_A_36	0xf6
-#define MAC_REG_RSPINF_A_48	0xf8
-#define MAC_REG_RSPINF_A_54	0xfa
-#define MAC_REG_RSPINF_A_72	0xfc
-
-/* Bits in the I2MCFG EEPROM register */
-#define I2MCFG_BOUNDCTL		BIT(7)
-#define I2MCFG_WAITCTL		BIT(5)
-#define I2MCFG_SCLOECTL		BIT(4)
-#define I2MCFG_WBUSYCTL		BIT(3)
-#define I2MCFG_NORETRY		BIT(2)
-#define I2MCFG_I2MLDSEQ		BIT(1)
-#define I2MCFG_I2CMFAST		BIT(0)
-
-/* Bits in the I2MCSR EEPROM register */
-#define I2MCSR_EEMW		BIT(7)
-#define I2MCSR_EEMR		BIT(6)
-#define I2MCSR_AUTOLD		BIT(3)
-#define I2MCSR_NACK		BIT(1)
-#define I2MCSR_DONE		BIT(0)
-
-/* Bits in the TMCTL register */
-#define TMCTL_TSUSP		BIT(2)
-#define TMCTL_TMD		BIT(1)
-#define TMCTL_TE		BIT(0)
-
-/* Bits in the TFTCTL register */
-#define TFTCTL_HWUTSF		BIT(7)
-#define TFTCTL_TBTTSYNC		BIT(6)
-#define TFTCTL_HWUTSFEN		BIT(5)
-#define TFTCTL_TSFCNTRRD	BIT(4)
-#define TFTCTL_TBTTSYNCEN	BIT(3)
-#define TFTCTL_TSFSYNCEN	BIT(2)
-#define TFTCTL_TSFCNTRST	BIT(1)
-#define TFTCTL_TSFCNTREN	BIT(0)
-
-/* Bits in the EnhanceCFG_0 register */
-#define EN_CFG_BB_TYPE_A	0x00
-#define EN_CFG_BB_TYPE_B	BIT(0)
-#define EN_CFG_BB_TYPE_G	BIT(1)
-#define EN_CFG_BB_TYPE_MASK	(EN_CFG_BB_TYPE_B | EN_CFG_BB_TYPE_G)
-#define EN_CFG_PROTECT_MD	BIT(5)
-
-/* Bits in the EnhanceCFG_1 register */
-#define EN_CFG_BCN_SUS_IND	BIT(0)
-#define EN_CFG_BCN_SUS_CLR	BIT(1)
-
-/* Bits in the EnhanceCFG_2 register */
-#define EN_CFG_NXTBTTCFPSTR	BIT(0)
-#define EN_CFG_BARKER_PREAM	BIT(1)
-#define EN_CFG_PKT_BURST_MD	BIT(2)
-
-/* Bits in the CFG register */
-#define CFG_TKIPOPT		BIT(7)
-#define CFG_RXDMAOPT		BIT(6)
-#define CFG_TMOT_SW		BIT(5)
-#define CFG_TMOT_HWLONG		BIT(4)
-#define CFG_TMOT_HW		0x00
-#define CFG_CFPENDOPT		BIT(3)
-#define CFG_BCNSUSEN		BIT(2)
-#define CFG_NOTXTIMEOUT		BIT(1)
-#define CFG_NOBUFOPT		BIT(0)
-
-/* Bits in the TEST register */
-#define TEST_LBEXT		BIT(7)
-#define TEST_LBINT		BIT(6)
-#define TEST_LBNONE		0x00
-#define TEST_SOFTINT		BIT(5)
-#define TEST_CONTTX		BIT(4)
-#define TEST_TXPE		BIT(3)
-#define TEST_NAVDIS		BIT(2)
-#define TEST_NOCTS		BIT(1)
-#define TEST_NOACK		BIT(0)
-
-/* Bits in the HOSTCR register */
-#define HOSTCR_TXONST		BIT(7)
-#define HOSTCR_RXONST		BIT(6)
-#define HOSTCR_ADHOC		BIT(5)
-#define HOSTCR_AP		BIT(4)
-#define HOSTCR_TXON		BIT(3)
-#define HOSTCR_RXON		BIT(2)
-#define HOSTCR_MACEN		BIT(1)
-#define HOSTCR_SOFTRST		BIT(0)
-
-/* Bits in the MACCR register */
-#define MACCR_SYNCFLUSHOK	BIT(2)
-#define MACCR_SYNCFLUSH		BIT(1)
-#define MACCR_CLRNAV		BIT(0)
-
-/* Bits in the RCR register */
-#define RCR_SSID		BIT(7)
-#define RCR_RXALLTYPE		BIT(6)
-#define RCR_UNICAST		BIT(5)
-#define RCR_BROADCAST		BIT(4)
-#define RCR_MULTICAST		BIT(3)
-#define RCR_WPAERR		BIT(2)
-#define RCR_ERRCRC		BIT(1)
-#define RCR_BSSID		BIT(0)
-
-/* Bits in the TCR register */
-#define TCR_SYNCDCFOPT		BIT(1)
-#define TCR_AUTOBCNTX		BIT(0)
-
-/* ISR1 */
-#define ISR_GPIO3		BIT(6)
-#define ISR_RXNOBUF		BIT(3)
-#define ISR_MIBNEARFULL		BIT(2)
-#define ISR_SOFTINT		BIT(1)
-#define ISR_FETALERR		BIT(0)
-
-#define LEDSTS_STS		0x06
-#define LEDSTS_TMLEN		0x78
-#define LEDSTS_OFF		0x00
-#define LEDSTS_ON		0x02
-#define LEDSTS_SLOW		0x04
-#define LEDSTS_INTER		0x06
-
-/* ISR0 */
-#define ISR_WATCHDOG		BIT(7)
-#define ISR_SOFTTIMER		BIT(6)
-#define ISR_GPIO0		BIT(5)
-#define ISR_TBTT		BIT(4)
-#define ISR_RXDMA0		BIT(3)
-#define ISR_BNTX		BIT(2)
-#define ISR_ACTX		BIT(0)
-
-/* Bits in the PSCFG register */
-#define PSCFG_PHILIPMD		BIT(6)
-#define PSCFG_WAKECALEN		BIT(5)
-#define PSCFG_WAKETMREN		BIT(4)
-#define PSCFG_BBPSPROG		BIT(3)
-#define PSCFG_WAKESYN		BIT(2)
-#define PSCFG_SLEEPSYN		BIT(1)
-#define PSCFG_AUTOSLEEP		BIT(0)
-
-/* Bits in the PSCTL register */
-#define PSCTL_WAKEDONE		BIT(5)
-#define PSCTL_PS		BIT(4)
-#define PSCTL_GO2DOZE		BIT(3)
-#define PSCTL_LNBCN		BIT(2)
-#define PSCTL_ALBCN		BIT(1)
-#define PSCTL_PSEN		BIT(0)
-
-/* Bits in the PSPWSIG register */
-#define PSSIG_WPE3		BIT(7)
-#define PSSIG_WPE2		BIT(6)
-#define PSSIG_WPE1		BIT(5)
-#define PSSIG_WRADIOPE		BIT(4)
-#define PSSIG_SPE3		BIT(3)
-#define PSSIG_SPE2		BIT(2)
-#define PSSIG_SPE1		BIT(1)
-#define PSSIG_SRADIOPE		BIT(0)
-
-/* Bits in the BBREGCTL register */
-#define BBREGCTL_DONE		BIT(2)
-#define BBREGCTL_REGR		BIT(1)
-#define BBREGCTL_REGW		BIT(0)
-
-/* Bits in the IFREGCTL register */
-#define IFREGCTL_DONE		BIT(2)
-#define IFREGCTL_IFRF		BIT(1)
-#define IFREGCTL_REGW		BIT(0)
-
-/* Bits in the SOFTPWRCTL register */
-#define SOFTPWRCTL_RFLEOPT	BIT(3)
-#define SOFTPWRCTL_TXPEINV	BIT(1)
-#define SOFTPWRCTL_SWPECTI	BIT(0)
-#define SOFTPWRCTL_SWPAPE	BIT(5)
-#define SOFTPWRCTL_SWCALEN	BIT(4)
-#define SOFTPWRCTL_SWRADIO_PE	BIT(3)
-#define SOFTPWRCTL_SWPE2	BIT(2)
-#define SOFTPWRCTL_SWPE1	BIT(1)
-#define SOFTPWRCTL_SWPE3	BIT(0)
-
-/* Bits in the GPIOCTL1 register */
-#define GPIO3_MD		BIT(5)
-#define GPIO3_DATA		BIT(6)
-#define GPIO3_INTMD		BIT(7)
-
-/* Bits in the MISCFFCTL register */
-#define MISCFFCTL_WRITE		BIT(0)
-
-/* Loopback mode */
-#define MAC_LB_EXT		BIT(1)
-#define MAC_LB_INTERNAL		BIT(0)
-#define MAC_LB_NONE		0x00
-
-/* Ethernet address filter type */
-#define PKT_TYPE_NONE		0x00 /* turn off receiver */
-#define PKT_TYPE_ALL_MULTICAST	BIT(7)
-#define PKT_TYPE_PROMISCUOUS	BIT(6)
-#define PKT_TYPE_DIRECTED	BIT(5)	/* obselete */
-#define PKT_TYPE_BROADCAST	BIT(4)
-#define PKT_TYPE_MULTICAST	BIT(3)
-#define PKT_TYPE_ERROR_WPA	BIT(2)
-#define PKT_TYPE_ERROR_CRC	BIT(1)
-#define PKT_TYPE_BSSID		BIT(0)
-
-#define DEFAULT_BI		0x200
-
-/* MiscFIFO Offset */
-#define MISCFIFO_KEYETRY0	32
-#define MISCFIFO_KEYENTRYSIZE	22
-
-#define MAC_REVISION_A0		0x00
-#define MAC_REVISION_A1		0x01
-
-struct vnt_mac_set_key {
-	union {
-		struct {
-			u8 addr[ETH_ALEN];
-			__le16 key_ctl;
-		} write __packed;
-		u32 swap[2];
-	} u;
-	u8 key[WLAN_KEY_LEN_CCMP];
-} __packed;
-
-int vnt_mac_set_filter(struct vnt_private *priv, u64 mc_filter);
-int vnt_mac_shutdown(struct vnt_private *priv);
-int vnt_mac_set_bb_type(struct vnt_private *priv, u8 type);
-int vnt_mac_disable_keyentry(struct vnt_private *priv, u8 entry_idx);
-int vnt_mac_set_keyentry(struct vnt_private *priv, u16 key_ctl, u32 entry_idx,
-			 u32 key_idx, u8 *addr, u8 *key);
-int vnt_mac_reg_bits_off(struct vnt_private *priv, u8 reg_ofs, u8 bits);
-int vnt_mac_reg_bits_on(struct vnt_private *priv, u8 reg_ofs, u8 bits);
-int vnt_mac_write_word(struct vnt_private *priv, u8 reg_ofs, u16 word);
-int vnt_mac_set_bssid_addr(struct vnt_private *priv, u8 *addr);
-int vnt_mac_enable_protect_mode(struct vnt_private *priv);
-int vnt_mac_disable_protect_mode(struct vnt_private *priv);
-int vnt_mac_enable_barker_preamble_mode(struct vnt_private *priv);
-int vnt_mac_disable_barker_preamble_mode(struct vnt_private *priv);
-int vnt_mac_set_beacon_interval(struct vnt_private *priv, u16 interval);
-int vnt_mac_set_led(struct vnt_private *privpriv, u8 state, u8 led);
-
-#endif /* __MAC_H__ */
diff --git a/drivers/staging/vt6656/main_usb.c b/drivers/staging/vt6656/main_usb.c
deleted file mode 100644
index 4f09e733e7a8..000000000000
--- a/drivers/staging/vt6656/main_usb.c
+++ /dev/null
@@ -1,1121 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * Purpose: driver entry for initial, open, close, tx and rx.
- *
- * Author: Lyndon Chen
- *
- * Date: Dec 8, 2005
- *
- * Functions:
- *
- *   vt6656_probe - module initial (insmod) driver entry
- *   vnt_free_tx_bufs - free tx buffer function
- *   vnt_init_registers- initial MAC & BBP & RF internal registers.
- *
- * Revision History:
- */
-#undef __NO_VERSION__
-
-#include <linux/bits.h>
-#include <linux/etherdevice.h>
-#include <linux/file.h>
-#include <linux/kernel.h>
-#include "device.h"
-#include "card.h"
-#include "baseband.h"
-#include "mac.h"
-#include "power.h"
-#include "wcmd.h"
-#include "rxtx.h"
-#include "rf.h"
-#include "usbpipe.h"
-#include "channel.h"
-
-/*
- * define module options
- */
-
-/* version information */
-#define DRIVER_AUTHOR \
-	"VIA Networking Technologies, Inc., <lyndonchen@vntek.com.tw>"
-MODULE_AUTHOR(DRIVER_AUTHOR);
-MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION(DEVICE_FULL_DRV_NAM);
-
-#define RX_DESC_DEF0 64
-static int vnt_rx_buffers = RX_DESC_DEF0;
-module_param_named(rx_buffers, vnt_rx_buffers, int, 0644);
-MODULE_PARM_DESC(rx_buffers, "Number of receive usb rx buffers");
-
-#define TX_DESC_DEF0 64
-static int vnt_tx_buffers = TX_DESC_DEF0;
-module_param_named(tx_buffers, vnt_tx_buffers, int, 0644);
-MODULE_PARM_DESC(tx_buffers, "Number of receive usb tx buffers");
-
-#define RTS_THRESH_DEF     2347
-#define FRAG_THRESH_DEF     2346
-
-/* BasebandType[] baseband type selected
- * 0: indicate 802.11a type
- * 1: indicate 802.11b type
- * 2: indicate 802.11g type
- */
-
-#define BBP_TYPE_DEF     2
-
-/*
- * Static vars definitions
- */
-
-static const struct usb_device_id vt6656_table[] = {
-	{USB_DEVICE(VNT_USB_VENDOR_ID, VNT_USB_PRODUCT_ID)},
-	{}
-};
-
-static void vnt_set_options(struct vnt_private *priv)
-{
-	/* Set number of TX buffers */
-	if (vnt_tx_buffers < CB_MIN_TX_DESC || vnt_tx_buffers > CB_MAX_TX_DESC)
-		priv->num_tx_context = TX_DESC_DEF0;
-	else
-		priv->num_tx_context = vnt_tx_buffers;
-
-	/* Set number of RX buffers */
-	if (vnt_rx_buffers < CB_MIN_RX_DESC || vnt_rx_buffers > CB_MAX_RX_DESC)
-		priv->num_rcb = RX_DESC_DEF0;
-	else
-		priv->num_rcb = vnt_rx_buffers;
-
-	priv->op_mode = NL80211_IFTYPE_UNSPECIFIED;
-	priv->bb_type = BBP_TYPE_DEF;
-	priv->packet_type = priv->bb_type;
-	priv->preamble_type = PREAMBLE_LONG;
-	priv->exist_sw_net_addr = false;
-}
-
-static int vnt_download_firmware(struct vnt_private *priv)
-{
-	struct device *dev = &priv->usb->dev;
-	const struct firmware *fw;
-	u16 length;
-	int ii;
-	int ret = 0;
-
-	dev_dbg(dev, "---->Download firmware\n");
-
-	ret = request_firmware(&fw, FIRMWARE_NAME, dev);
-	if (ret) {
-		dev_err(dev, "firmware file %s request failed (%d)\n",
-			FIRMWARE_NAME, ret);
-		goto end;
-	}
-
-	for (ii = 0; ii < fw->size; ii += FIRMWARE_CHUNK_SIZE) {
-		length = min_t(int, fw->size - ii, FIRMWARE_CHUNK_SIZE);
-
-		ret = vnt_control_out(priv, 0, 0x1200 + ii, 0x0000, length,
-				      fw->data + ii);
-		if (ret)
-			goto free_fw;
-
-		dev_dbg(dev, "Download firmware...%d %zu\n", ii, fw->size);
-	}
-
-free_fw:
-	release_firmware(fw);
-end:
-	return ret;
-}
-
-static int vnt_firmware_branch_to_sram(struct vnt_private *priv)
-{
-	dev_dbg(&priv->usb->dev, "---->Branch to Sram\n");
-
-	return vnt_control_out(priv, 1, 0x1200, 0x0000, 0, NULL);
-}
-
-static int vnt_check_firmware_version(struct vnt_private *priv)
-{
-	int ret = 0;
-
-	ret = vnt_control_in(priv, MESSAGE_TYPE_READ, 0,
-			     MESSAGE_REQUEST_VERSION, 2,
-			     (u8 *)&priv->firmware_version);
-	if (ret) {
-		dev_dbg(&priv->usb->dev,
-			"Could not get firmware version: %d.\n", ret);
-		goto end;
-	}
-
-	dev_dbg(&priv->usb->dev, "Firmware Version [%04x]\n",
-		priv->firmware_version);
-
-	if (priv->firmware_version == 0xFFFF) {
-		dev_dbg(&priv->usb->dev, "In Loader.\n");
-		ret = -EINVAL;
-		goto end;
-	}
-
-	if (priv->firmware_version < FIRMWARE_VERSION) {
-		/* branch to loader for download new firmware */
-		ret = vnt_firmware_branch_to_sram(priv);
-		if (ret) {
-			dev_dbg(&priv->usb->dev,
-				"Could not branch to SRAM: %d.\n", ret);
-		} else {
-			ret = -EINVAL;
-		}
-	}
-
-end:
-	return ret;
-}
-
-/*
- * initialization of MAC & BBP registers
- */
-static int vnt_init_registers(struct vnt_private *priv)
-{
-	int ret;
-	struct vnt_cmd_card_init *init_cmd = &priv->init_command;
-	struct vnt_rsp_card_init *init_rsp = &priv->init_response;
-	u8 antenna;
-	int ii;
-	u8 tmp;
-	u8 calib_tx_iq = 0, calib_tx_dc = 0, calib_rx_iq = 0;
-
-	dev_dbg(&priv->usb->dev, "---->INIbInitAdapter. [%d][%d]\n",
-		DEVICE_INIT_COLD, priv->packet_type);
-
-	ret = vnt_check_firmware_version(priv);
-	if (ret) {
-		ret = vnt_download_firmware(priv);
-		if (ret) {
-			dev_dbg(&priv->usb->dev,
-				"Could not download firmware: %d.\n", ret);
-			goto end;
-		}
-
-		ret = vnt_firmware_branch_to_sram(priv);
-		if (ret) {
-			dev_dbg(&priv->usb->dev,
-				"Could not branch to SRAM: %d.\n", ret);
-			goto end;
-		}
-	}
-
-	ret = vnt_vt3184_init(priv);
-	if (ret) {
-		dev_dbg(&priv->usb->dev, "vnt_vt3184_init fail\n");
-		goto end;
-	}
-
-	init_cmd->init_class = DEVICE_INIT_COLD;
-	init_cmd->exist_sw_net_addr = priv->exist_sw_net_addr;
-	for (ii = 0; ii < ARRAY_SIZE(init_cmd->sw_net_addr); ii++)
-		init_cmd->sw_net_addr[ii] = priv->current_net_addr[ii];
-	init_cmd->short_retry_limit = priv->hw->wiphy->retry_short;
-	init_cmd->long_retry_limit = priv->hw->wiphy->retry_long;
-
-	/* issue card_init command to device */
-	ret = vnt_control_out(priv, MESSAGE_TYPE_CARDINIT, 0, 0,
-			      sizeof(struct vnt_cmd_card_init),
-			      (u8 *)init_cmd);
-	if (ret) {
-		dev_dbg(&priv->usb->dev, "Issue Card init fail\n");
-		goto end;
-	}
-
-	ret = vnt_control_in(priv, MESSAGE_TYPE_INIT_RSP, 0, 0,
-			     sizeof(struct vnt_rsp_card_init),
-			     (u8 *)init_rsp);
-	if (ret) {
-		dev_dbg(&priv->usb->dev, "Cardinit request in status fail!\n");
-		goto end;
-	}
-
-	/* local ID for AES functions */
-	ret = vnt_control_in(priv, MESSAGE_TYPE_READ, MAC_REG_LOCALID,
-			     MESSAGE_REQUEST_MACREG, 1, &priv->local_id);
-	if (ret)
-		goto end;
-
-	/* do MACbSoftwareReset in MACvInitialize */
-
-	priv->top_ofdm_basic_rate = RATE_24M;
-	priv->top_cck_basic_rate = RATE_1M;
-
-	/* target to IF pin while programming to RF chip */
-	priv->power = 0xFF;
-
-	priv->cck_pwr = priv->eeprom[EEP_OFS_PWR_CCK];
-	priv->ofdm_pwr_g = priv->eeprom[EEP_OFS_PWR_OFDMG];
-	/* load power table */
-	for (ii = 0; ii < ARRAY_SIZE(priv->cck_pwr_tbl); ii++) {
-		priv->cck_pwr_tbl[ii] =
-			priv->eeprom[ii + EEP_OFS_CCK_PWR_TBL];
-		if (priv->cck_pwr_tbl[ii] == 0)
-			priv->cck_pwr_tbl[ii] = priv->cck_pwr;
-
-		priv->ofdm_pwr_tbl[ii] =
-				priv->eeprom[ii + EEP_OFS_OFDM_PWR_TBL];
-		if (priv->ofdm_pwr_tbl[ii] == 0)
-			priv->ofdm_pwr_tbl[ii] = priv->ofdm_pwr_g;
-	}
-
-	/*
-	 * original zonetype is USA, but custom zonetype is Europe,
-	 * then need to recover 12, 13, 14 channels with 11 channel
-	 */
-	for (ii = 11; ii < ARRAY_SIZE(priv->cck_pwr_tbl); ii++) {
-		priv->cck_pwr_tbl[ii] = priv->cck_pwr_tbl[10];
-		priv->ofdm_pwr_tbl[ii] = priv->ofdm_pwr_tbl[10];
-	}
-
-	priv->ofdm_pwr_a = 0x34; /* same as RFbMA2829SelectChannel */
-
-	/* load OFDM A power table */
-	for (ii = 0; ii < CB_MAX_CHANNEL_5G; ii++) {
-		priv->ofdm_a_pwr_tbl[ii] =
-			priv->eeprom[ii + EEP_OFS_OFDMA_PWR_TBL];
-
-		if (priv->ofdm_a_pwr_tbl[ii] == 0)
-			priv->ofdm_a_pwr_tbl[ii] = priv->ofdm_pwr_a;
-	}
-
-	antenna = priv->eeprom[EEP_OFS_ANTENNA];
-
-	if (antenna & EEP_ANTINV)
-		priv->tx_rx_ant_inv = true;
-	else
-		priv->tx_rx_ant_inv = false;
-
-	antenna &= (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);
-
-	if (antenna == 0) /* if not set default is both */
-		antenna = (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);
-
-	if (antenna == (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN)) {
-		priv->tx_antenna_mode = ANT_B;
-		priv->rx_antenna_sel = 1;
-
-		if (priv->tx_rx_ant_inv)
-			priv->rx_antenna_mode = ANT_A;
-		else
-			priv->rx_antenna_mode = ANT_B;
-	} else  {
-		priv->rx_antenna_sel = 0;
-
-		if (antenna & EEP_ANTENNA_AUX) {
-			priv->tx_antenna_mode = ANT_A;
-
-			if (priv->tx_rx_ant_inv)
-				priv->rx_antenna_mode = ANT_B;
-			else
-				priv->rx_antenna_mode = ANT_A;
-		} else {
-			priv->tx_antenna_mode = ANT_B;
-
-			if (priv->tx_rx_ant_inv)
-				priv->rx_antenna_mode = ANT_A;
-			else
-				priv->rx_antenna_mode = ANT_B;
-		}
-	}
-
-	/* Set initial antenna mode */
-	ret = vnt_set_antenna_mode(priv, priv->rx_antenna_mode);
-	if (ret)
-		goto end;
-
-	/* default Auto Mode */
-	priv->bb_type = BB_TYPE_11G;
-
-	/* get RFType */
-	priv->rf_type = init_rsp->rf_type;
-
-	/* load vt3266 calibration parameters in EEPROM */
-	if (priv->rf_type == RF_VT3226D0) {
-		if ((priv->eeprom[EEP_OFS_MAJOR_VER] == 0x1) &&
-		    (priv->eeprom[EEP_OFS_MINOR_VER] >= 0x4)) {
-			calib_tx_iq = priv->eeprom[EEP_OFS_CALIB_TX_IQ];
-			calib_tx_dc = priv->eeprom[EEP_OFS_CALIB_TX_DC];
-			calib_rx_iq = priv->eeprom[EEP_OFS_CALIB_RX_IQ];
-			if (calib_tx_iq || calib_tx_dc || calib_rx_iq) {
-				/* CR255, enable TX/RX IQ and
-				 * DC compensation mode
-				 */
-				ret = vnt_control_out_u8(priv,
-							 MESSAGE_REQUEST_BBREG,
-							 0xff, 0x03);
-				if (ret)
-					goto end;
-
-				/* CR251, TX I/Q Imbalance Calibration */
-				ret = vnt_control_out_u8(priv,
-							 MESSAGE_REQUEST_BBREG,
-							 0xfb, calib_tx_iq);
-				if (ret)
-					goto end;
-
-				/* CR252, TX DC-Offset Calibration */
-				ret = vnt_control_out_u8(priv,
-							 MESSAGE_REQUEST_BBREG,
-							 0xfC, calib_tx_dc);
-				if (ret)
-					goto end;
-
-				/* CR253, RX I/Q Imbalance Calibration */
-				ret = vnt_control_out_u8(priv,
-							 MESSAGE_REQUEST_BBREG,
-							 0xfd, calib_rx_iq);
-				if (ret)
-					goto end;
-			} else {
-				/* CR255, turn off
-				 * BB Calibration compensation
-				 */
-				ret = vnt_control_out_u8(priv,
-							 MESSAGE_REQUEST_BBREG,
-							 0xff, 0x0);
-				if (ret)
-					goto end;
-			}
-		}
-	}
-
-	/* get permanent network address */
-	memcpy(priv->permanent_net_addr, init_rsp->net_addr, 6);
-	ether_addr_copy(priv->current_net_addr, priv->permanent_net_addr);
-
-	/* if exist SW network address, use it */
-	dev_dbg(&priv->usb->dev, "Network address = %pM\n",
-		priv->current_net_addr);
-
-	priv->radio_ctl = priv->eeprom[EEP_OFS_RADIOCTL];
-
-	if ((priv->radio_ctl & EEP_RADIOCTL_ENABLE) != 0) {
-		ret = vnt_control_in(priv, MESSAGE_TYPE_READ,
-				     MAC_REG_GPIOCTL1, MESSAGE_REQUEST_MACREG,
-				     1, &tmp);
-		if (ret)
-			goto end;
-
-		if ((tmp & GPIO3_DATA) == 0) {
-			ret = vnt_mac_reg_bits_on(priv, MAC_REG_GPIOCTL1,
-						  GPIO3_INTMD);
-		} else {
-			ret = vnt_mac_reg_bits_off(priv, MAC_REG_GPIOCTL1,
-						   GPIO3_INTMD);
-		}
-
-		if (ret)
-			goto end;
-	}
-
-	ret = vnt_mac_set_led(priv, LEDSTS_TMLEN, 0x38);
-	if (ret)
-		goto end;
-
-	ret = vnt_mac_set_led(priv, LEDSTS_STS, LEDSTS_SLOW);
-	if (ret)
-		goto end;
-
-	ret = vnt_mac_reg_bits_on(priv, MAC_REG_GPIOCTL0, BIT(0));
-	if (ret)
-		goto end;
-
-	ret = vnt_radio_power_on(priv);
-	if (ret)
-		goto end;
-
-	dev_dbg(&priv->usb->dev, "<----INIbInitAdapter Exit\n");
-
-end:
-	return ret;
-}
-
-static void vnt_free_tx_bufs(struct vnt_private *priv)
-{
-	struct vnt_usb_send_context *tx_context;
-	int ii;
-
-	usb_kill_anchored_urbs(&priv->tx_submitted);
-
-	for (ii = 0; ii < priv->num_tx_context; ii++) {
-		tx_context = priv->tx_context[ii];
-		if (!tx_context)
-			continue;
-
-		kfree(tx_context);
-	}
-}
-
-static void vnt_free_rx_bufs(struct vnt_private *priv)
-{
-	struct vnt_rcb *rcb;
-	int ii;
-
-	for (ii = 0; ii < priv->num_rcb; ii++) {
-		rcb = priv->rcb[ii];
-		if (!rcb)
-			continue;
-
-		/* deallocate URBs */
-		if (rcb->urb) {
-			usb_kill_urb(rcb->urb);
-			usb_free_urb(rcb->urb);
-		}
-
-		/* deallocate skb */
-		if (rcb->skb)
-			dev_kfree_skb(rcb->skb);
-
-		kfree(rcb);
-	}
-}
-
-static void vnt_free_int_bufs(struct vnt_private *priv)
-{
-	kfree(priv->int_buf.data_buf);
-}
-
-static int vnt_alloc_bufs(struct vnt_private *priv)
-{
-	int ret;
-	struct vnt_usb_send_context *tx_context;
-	struct vnt_rcb *rcb;
-	int ii;
-
-	init_usb_anchor(&priv->tx_submitted);
-
-	for (ii = 0; ii < priv->num_tx_context; ii++) {
-		tx_context = kmalloc(sizeof(*tx_context), GFP_KERNEL);
-		if (!tx_context) {
-			ret = -ENOMEM;
-			goto free_tx;
-		}
-
-		priv->tx_context[ii] = tx_context;
-		tx_context->priv = priv;
-		tx_context->pkt_no = ii;
-		tx_context->in_use = false;
-	}
-
-	for (ii = 0; ii < priv->num_rcb; ii++) {
-		priv->rcb[ii] = kzalloc(sizeof(*priv->rcb[ii]), GFP_KERNEL);
-		if (!priv->rcb[ii]) {
-			ret = -ENOMEM;
-			goto free_rx_tx;
-		}
-
-		rcb = priv->rcb[ii];
-
-		rcb->priv = priv;
-
-		/* allocate URBs */
-		rcb->urb = usb_alloc_urb(0, GFP_KERNEL);
-		if (!rcb->urb) {
-			ret = -ENOMEM;
-			goto free_rx_tx;
-		}
-
-		rcb->skb = dev_alloc_skb(priv->rx_buf_sz);
-		if (!rcb->skb) {
-			ret = -ENOMEM;
-			goto free_rx_tx;
-		}
-		/* submit rx urb */
-		ret = vnt_submit_rx_urb(priv, rcb);
-		if (ret)
-			goto free_rx_tx;
-	}
-
-	priv->interrupt_urb = usb_alloc_urb(0, GFP_KERNEL);
-	if (!priv->interrupt_urb) {
-		ret = -ENOMEM;
-		goto free_rx_tx;
-	}
-
-	priv->int_buf.data_buf = kmalloc(MAX_INTERRUPT_SIZE, GFP_KERNEL);
-	if (!priv->int_buf.data_buf) {
-		ret = -ENOMEM;
-		goto free_rx_tx_urb;
-	}
-
-	return 0;
-
-free_rx_tx_urb:
-	usb_free_urb(priv->interrupt_urb);
-free_rx_tx:
-	vnt_free_rx_bufs(priv);
-free_tx:
-	vnt_free_tx_bufs(priv);
-	return ret;
-}
-
-static void vnt_tx_80211(struct ieee80211_hw *hw,
-			 struct ieee80211_tx_control *control,
-			 struct sk_buff *skb)
-{
-	struct vnt_private *priv = hw->priv;
-
-	if (vnt_tx_packet(priv, skb))
-		ieee80211_free_txskb(hw, skb);
-}
-
-static int vnt_start(struct ieee80211_hw *hw)
-{
-	int ret;
-	struct vnt_private *priv = hw->priv;
-
-	priv->rx_buf_sz = MAX_TOTAL_SIZE_WITH_ALL_HEADERS;
-
-	ret = vnt_alloc_bufs(priv);
-	if (ret) {
-		dev_dbg(&priv->usb->dev, "vnt_alloc_bufs fail...\n");
-		goto err;
-	}
-
-	clear_bit(DEVICE_FLAGS_DISCONNECTED, &priv->flags);
-
-	ret = vnt_init_registers(priv);
-	if (ret) {
-		dev_dbg(&priv->usb->dev, " init register fail\n");
-		goto free_all;
-	}
-
-	ret = vnt_key_init_table(priv);
-	if (ret)
-		goto free_all;
-
-	priv->int_interval = 1;  /* bInterval is set to 1 */
-
-	ret = vnt_start_interrupt_urb(priv);
-	if (ret)
-		goto free_all;
-
-	ieee80211_wake_queues(hw);
-
-	return 0;
-
-free_all:
-	vnt_free_rx_bufs(priv);
-	vnt_free_tx_bufs(priv);
-	vnt_free_int_bufs(priv);
-
-	usb_kill_urb(priv->interrupt_urb);
-	usb_free_urb(priv->interrupt_urb);
-err:
-	return ret;
-}
-
-static void vnt_stop(struct ieee80211_hw *hw, bool suspend)
-{
-	struct vnt_private *priv = hw->priv;
-	int i;
-
-	if (!priv)
-		return;
-
-	for (i = 0; i < MAX_KEY_TABLE; i++)
-		vnt_mac_disable_keyentry(priv, i);
-
-	/* clear all keys */
-	priv->key_entry_inuse = 0;
-
-	if (!test_bit(DEVICE_FLAGS_UNPLUG, &priv->flags))
-		vnt_mac_shutdown(priv);
-
-	ieee80211_stop_queues(hw);
-
-	set_bit(DEVICE_FLAGS_DISCONNECTED, &priv->flags);
-
-	cancel_delayed_work_sync(&priv->run_command_work);
-
-	priv->cmd_running = false;
-
-	vnt_free_tx_bufs(priv);
-	vnt_free_rx_bufs(priv);
-	vnt_free_int_bufs(priv);
-
-	usb_kill_urb(priv->interrupt_urb);
-	usb_free_urb(priv->interrupt_urb);
-}
-
-static int vnt_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
-{
-	struct vnt_private *priv = hw->priv;
-
-	priv->vif = vif;
-
-	switch (vif->type) {
-	case NL80211_IFTYPE_STATION:
-		break;
-	case NL80211_IFTYPE_ADHOC:
-		vnt_mac_reg_bits_off(priv, MAC_REG_RCR, RCR_UNICAST);
-
-		vnt_mac_reg_bits_on(priv, MAC_REG_HOSTCR, HOSTCR_ADHOC);
-
-		break;
-	case NL80211_IFTYPE_AP:
-		vnt_mac_reg_bits_off(priv, MAC_REG_RCR, RCR_UNICAST);
-
-		vnt_mac_reg_bits_on(priv, MAC_REG_HOSTCR, HOSTCR_AP);
-
-		break;
-	default:
-		return -EOPNOTSUPP;
-	}
-
-	priv->op_mode = vif->type;
-
-	/* LED blink on TX */
-	vnt_mac_set_led(priv, LEDSTS_STS, LEDSTS_INTER);
-
-	return 0;
-}
-
-static void vnt_remove_interface(struct ieee80211_hw *hw,
-				 struct ieee80211_vif *vif)
-{
-	struct vnt_private *priv = hw->priv;
-
-	switch (vif->type) {
-	case NL80211_IFTYPE_STATION:
-		break;
-	case NL80211_IFTYPE_ADHOC:
-		vnt_mac_reg_bits_off(priv, MAC_REG_TCR, TCR_AUTOBCNTX);
-		vnt_mac_reg_bits_off(priv, MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);
-		vnt_mac_reg_bits_off(priv, MAC_REG_HOSTCR, HOSTCR_ADHOC);
-		break;
-	case NL80211_IFTYPE_AP:
-		vnt_mac_reg_bits_off(priv, MAC_REG_TCR, TCR_AUTOBCNTX);
-		vnt_mac_reg_bits_off(priv, MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);
-		vnt_mac_reg_bits_off(priv, MAC_REG_HOSTCR, HOSTCR_AP);
-		break;
-	default:
-		break;
-	}
-
-	vnt_radio_power_off(priv);
-
-	priv->op_mode = NL80211_IFTYPE_UNSPECIFIED;
-
-	/* LED slow blink */
-	vnt_mac_set_led(priv, LEDSTS_STS, LEDSTS_SLOW);
-}
-
-static int vnt_config(struct ieee80211_hw *hw, u32 changed)
-{
-	struct vnt_private *priv = hw->priv;
-	struct ieee80211_conf *conf = &hw->conf;
-
-	if (changed & IEEE80211_CONF_CHANGE_PS) {
-		if (conf->flags & IEEE80211_CONF_PS)
-			vnt_enable_power_saving(priv, conf->listen_interval);
-		else
-			vnt_disable_power_saving(priv);
-	}
-
-	if ((changed & IEEE80211_CONF_CHANGE_CHANNEL) ||
-	    (conf->flags & IEEE80211_CONF_OFFCHANNEL)) {
-		vnt_set_channel(priv, conf->chandef.chan->hw_value);
-
-		if (conf->chandef.chan->band == NL80211_BAND_5GHZ)
-			priv->bb_type = BB_TYPE_11A;
-		else
-			priv->bb_type = BB_TYPE_11G;
-	}
-
-	if (changed & IEEE80211_CONF_CHANGE_POWER)
-		vnt_rf_setpower(priv, conf->chandef.chan);
-
-	if (conf->flags & (IEEE80211_CONF_OFFCHANNEL | IEEE80211_CONF_IDLE))
-		/* Set max sensitivity*/
-		vnt_update_pre_ed_threshold(priv, true);
-	else
-		vnt_update_pre_ed_threshold(priv, false);
-
-	return 0;
-}
-
-static void vnt_bss_info_changed(struct ieee80211_hw *hw,
-				 struct ieee80211_vif *vif,
-				 struct ieee80211_bss_conf *conf, u64 changed)
-{
-	struct vnt_private *priv = hw->priv;
-
-	priv->current_aid = vif->cfg.aid;
-
-	if (changed & BSS_CHANGED_BSSID && conf->bssid)
-		vnt_mac_set_bssid_addr(priv, (u8 *)conf->bssid);
-
-	if (changed & BSS_CHANGED_BASIC_RATES) {
-		priv->basic_rates = conf->basic_rates;
-
-		vnt_update_top_rates(priv);
-
-		dev_dbg(&priv->usb->dev, "basic rates %x\n", conf->basic_rates);
-	}
-
-	if (changed & BSS_CHANGED_ERP_PREAMBLE) {
-		if (conf->use_short_preamble) {
-			vnt_mac_enable_barker_preamble_mode(priv);
-			priv->preamble_type = PREAMBLE_SHORT;
-		} else {
-			vnt_mac_disable_barker_preamble_mode(priv);
-			priv->preamble_type = PREAMBLE_LONG;
-		}
-	}
-
-	if (changed & BSS_CHANGED_ERP_CTS_PROT) {
-		if (conf->use_cts_prot)
-			vnt_mac_enable_protect_mode(priv);
-		else
-			vnt_mac_disable_protect_mode(priv);
-	}
-
-	if (changed & BSS_CHANGED_ERP_SLOT) {
-		if (conf->use_short_slot)
-			priv->short_slot_time = true;
-		else
-			priv->short_slot_time = false;
-
-		vnt_set_short_slot_time(priv);
-		vnt_set_vga_gain_offset(priv, priv->bb_vga[0]);
-	}
-
-	if (changed & (BSS_CHANGED_BASIC_RATES | BSS_CHANGED_ERP_PREAMBLE |
-		       BSS_CHANGED_ERP_SLOT))
-		vnt_set_bss_mode(priv);
-
-	if (changed & (BSS_CHANGED_TXPOWER | BSS_CHANGED_BANDWIDTH))
-		vnt_rf_setpower(priv, conf->chanreq.oper.chan);
-
-	if (changed & BSS_CHANGED_BEACON_ENABLED) {
-		dev_dbg(&priv->usb->dev,
-			"Beacon enable %d\n", conf->enable_beacon);
-
-		if (conf->enable_beacon) {
-			vnt_beacon_enable(priv, vif, conf);
-
-			vnt_mac_reg_bits_on(priv, MAC_REG_TCR, TCR_AUTOBCNTX);
-		} else {
-			vnt_mac_reg_bits_off(priv, MAC_REG_TCR, TCR_AUTOBCNTX);
-		}
-	}
-
-	if (changed & (BSS_CHANGED_ASSOC | BSS_CHANGED_BEACON_INFO) &&
-	    priv->op_mode != NL80211_IFTYPE_AP) {
-		if (vif->cfg.assoc && conf->beacon_rate) {
-			u16 ps_beacon_int = conf->beacon_int;
-
-			if (conf->dtim_period)
-				ps_beacon_int *= conf->dtim_period;
-			else if (hw->conf.listen_interval)
-				ps_beacon_int *= hw->conf.listen_interval;
-
-			vnt_mac_reg_bits_on(priv, MAC_REG_TFTCTL,
-					    TFTCTL_TSFCNTREN);
-
-			vnt_mac_set_beacon_interval(priv, ps_beacon_int);
-
-			vnt_reset_next_tbtt(priv, conf->beacon_int);
-
-			vnt_adjust_tsf(priv, conf->beacon_rate->hw_value,
-				       conf->sync_tsf, priv->current_tsf);
-
-			vnt_update_next_tbtt(priv,
-					     conf->sync_tsf, ps_beacon_int);
-		} else {
-			vnt_clear_current_tsf(priv);
-
-			vnt_mac_reg_bits_off(priv, MAC_REG_TFTCTL,
-					     TFTCTL_TSFCNTREN);
-		}
-	}
-}
-
-static u64 vnt_prepare_multicast(struct ieee80211_hw *hw,
-				 struct netdev_hw_addr_list *mc_list)
-{
-	struct vnt_private *priv = hw->priv;
-	struct netdev_hw_addr *ha;
-	u64 mc_filter = 0;
-	u32 bit_nr;
-
-	netdev_hw_addr_list_for_each(ha, mc_list) {
-		bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;
-		mc_filter |= BIT_ULL(bit_nr);
-	}
-
-	priv->mc_list_count = mc_list->count;
-
-	return mc_filter;
-}
-
-static void vnt_configure(struct ieee80211_hw *hw,
-			  unsigned int changed_flags,
-			  unsigned int *total_flags, u64 multicast)
-{
-	struct vnt_private *priv = hw->priv;
-	u8 rx_mode = 0;
-
-	*total_flags &= FIF_ALLMULTI | FIF_OTHER_BSS | FIF_BCN_PRBRESP_PROMISC;
-
-	vnt_control_in(priv, MESSAGE_TYPE_READ, MAC_REG_RCR,
-		       MESSAGE_REQUEST_MACREG, sizeof(u8), &rx_mode);
-
-	dev_dbg(&priv->usb->dev, "rx mode in = %x\n", rx_mode);
-
-	if (changed_flags & FIF_ALLMULTI) {
-		if (*total_flags & FIF_ALLMULTI) {
-			if (priv->mc_list_count > 2)
-				vnt_mac_set_filter(priv, ~0);
-			else
-				vnt_mac_set_filter(priv, multicast);
-
-			rx_mode |= RCR_MULTICAST | RCR_BROADCAST;
-		} else {
-			rx_mode &= ~(RCR_MULTICAST | RCR_BROADCAST);
-		}
-	}
-
-	if (changed_flags & (FIF_OTHER_BSS | FIF_BCN_PRBRESP_PROMISC)) {
-		if (*total_flags & (FIF_OTHER_BSS | FIF_BCN_PRBRESP_PROMISC))
-			rx_mode &= ~RCR_BSSID;
-		else
-			rx_mode |= RCR_BSSID;
-	}
-
-	vnt_control_out_u8(priv, MESSAGE_REQUEST_MACREG, MAC_REG_RCR, rx_mode);
-
-	dev_dbg(&priv->usb->dev, "rx mode out= %x\n", rx_mode);
-}
-
-static int vnt_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,
-		       struct ieee80211_vif *vif, struct ieee80211_sta *sta,
-		       struct ieee80211_key_conf *key)
-{
-	struct vnt_private *priv = hw->priv;
-
-	switch (cmd) {
-	case SET_KEY:
-		return vnt_set_keys(hw, sta, vif, key);
-	case DISABLE_KEY:
-		if (test_bit(key->hw_key_idx, &priv->key_entry_inuse)) {
-			clear_bit(key->hw_key_idx, &priv->key_entry_inuse);
-
-			vnt_mac_disable_keyentry(priv, key->hw_key_idx);
-		}
-		break;
-
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static int vnt_get_stats(struct ieee80211_hw *hw,
-			 struct ieee80211_low_level_stats *stats)
-{
-	struct vnt_private *priv = hw->priv;
-
-	memcpy(stats, &priv->low_stats, sizeof(*stats));
-
-	return 0;
-}
-
-static u64 vnt_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
-{
-	struct vnt_private *priv = hw->priv;
-
-	return priv->current_tsf;
-}
-
-static void vnt_set_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
-			u64 tsf)
-{
-	struct vnt_private *priv = hw->priv;
-
-	vnt_update_next_tbtt(priv, tsf, vif->bss_conf.beacon_int);
-}
-
-static void vnt_reset_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
-{
-	struct vnt_private *priv = hw->priv;
-
-	vnt_mac_reg_bits_off(priv, MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);
-
-	vnt_clear_current_tsf(priv);
-}
-
-static const struct ieee80211_ops vnt_mac_ops = {
-	.add_chanctx = ieee80211_emulate_add_chanctx,
-	.remove_chanctx = ieee80211_emulate_remove_chanctx,
-	.change_chanctx = ieee80211_emulate_change_chanctx,
-	.switch_vif_chanctx = ieee80211_emulate_switch_vif_chanctx,
-	.tx			= vnt_tx_80211,
-	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
-	.start			= vnt_start,
-	.stop			= vnt_stop,
-	.add_interface		= vnt_add_interface,
-	.remove_interface	= vnt_remove_interface,
-	.config			= vnt_config,
-	.bss_info_changed	= vnt_bss_info_changed,
-	.prepare_multicast	= vnt_prepare_multicast,
-	.configure_filter	= vnt_configure,
-	.set_key		= vnt_set_key,
-	.get_stats		= vnt_get_stats,
-	.get_tsf		= vnt_get_tsf,
-	.set_tsf		= vnt_set_tsf,
-	.reset_tsf		= vnt_reset_tsf,
-};
-
-int vnt_init(struct vnt_private *priv)
-{
-	if (vnt_init_registers(priv))
-		return -EAGAIN;
-
-	SET_IEEE80211_PERM_ADDR(priv->hw, priv->permanent_net_addr);
-
-	vnt_init_bands(priv);
-
-	if (ieee80211_register_hw(priv->hw))
-		return -ENODEV;
-
-	priv->mac_hw = true;
-
-	vnt_radio_power_off(priv);
-
-	return 0;
-}
-
-static int
-vt6656_probe(struct usb_interface *intf, const struct usb_device_id *id)
-{
-	struct usb_device *udev;
-	struct vnt_private *priv;
-	struct ieee80211_hw *hw;
-	struct wiphy *wiphy;
-	int rc;
-
-	udev = usb_get_dev(interface_to_usbdev(intf));
-
-	dev_notice(&udev->dev, "%s Ver. %s\n",
-		   DEVICE_FULL_DRV_NAM, DEVICE_VERSION);
-	dev_notice(&udev->dev,
-		   "Copyright (c) 2004 VIA Networking Technologies, Inc.\n");
-
-	hw = ieee80211_alloc_hw(sizeof(struct vnt_private), &vnt_mac_ops);
-	if (!hw) {
-		dev_err(&udev->dev, "could not register ieee80211_hw\n");
-		rc = -ENOMEM;
-		goto err_nomem;
-	}
-
-	priv = hw->priv;
-	priv->hw = hw;
-	priv->usb = udev;
-	priv->intf = intf;
-
-	vnt_set_options(priv);
-
-	spin_lock_init(&priv->lock);
-	mutex_init(&priv->usb_lock);
-
-	INIT_DELAYED_WORK(&priv->run_command_work, vnt_run_command);
-
-	usb_set_intfdata(intf, priv);
-
-	wiphy = priv->hw->wiphy;
-
-	wiphy->frag_threshold = FRAG_THRESH_DEF;
-	wiphy->rts_threshold = RTS_THRESH_DEF;
-	wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |
-		BIT(NL80211_IFTYPE_ADHOC) | BIT(NL80211_IFTYPE_AP);
-
-	ieee80211_hw_set(priv->hw, TIMING_BEACON_ONLY);
-	ieee80211_hw_set(priv->hw, SIGNAL_DBM);
-	ieee80211_hw_set(priv->hw, RX_INCLUDES_FCS);
-	ieee80211_hw_set(priv->hw, REPORTS_TX_ACK_STATUS);
-	ieee80211_hw_set(priv->hw, SUPPORTS_PS);
-	ieee80211_hw_set(priv->hw, PS_NULLFUNC_STACK);
-
-	priv->hw->extra_tx_headroom =
-		sizeof(struct vnt_tx_buffer) + sizeof(struct vnt_tx_usb_header);
-	priv->hw->max_signal = 100;
-
-	SET_IEEE80211_DEV(priv->hw, &intf->dev);
-
-	rc = usb_reset_device(priv->usb);
-	if (rc)
-		dev_warn(&priv->usb->dev,
-			 "%s reset fail status=%d\n", __func__, rc);
-
-	clear_bit(DEVICE_FLAGS_DISCONNECTED, &priv->flags);
-	vnt_reset_command_timer(priv);
-
-	vnt_schedule_command(priv, WLAN_CMD_INIT_MAC80211);
-
-	return 0;
-
-err_nomem:
-	usb_put_dev(udev);
-
-	return rc;
-}
-
-static void vt6656_disconnect(struct usb_interface *intf)
-{
-	struct vnt_private *priv = usb_get_intfdata(intf);
-
-	if (!priv)
-		return;
-
-	if (priv->mac_hw)
-		ieee80211_unregister_hw(priv->hw);
-
-	usb_set_intfdata(intf, NULL);
-	usb_put_dev(interface_to_usbdev(intf));
-
-	set_bit(DEVICE_FLAGS_UNPLUG, &priv->flags);
-
-	ieee80211_free_hw(priv->hw);
-}
-
-#ifdef CONFIG_PM
-
-static int vt6656_suspend(struct usb_interface *intf, pm_message_t message)
-{
-	return 0;
-}
-
-static int vt6656_resume(struct usb_interface *intf)
-{
-	return 0;
-}
-
-#endif /* CONFIG_PM */
-
-MODULE_DEVICE_TABLE(usb, vt6656_table);
-
-static struct usb_driver vt6656_driver = {
-	.name =		DEVICE_NAME,
-	.probe =	vt6656_probe,
-	.disconnect =	vt6656_disconnect,
-	.id_table =	vt6656_table,
-#ifdef CONFIG_PM
-	.suspend = vt6656_suspend,
-	.resume = vt6656_resume,
-#endif /* CONFIG_PM */
-};
-
-module_usb_driver(vt6656_driver);
-
-MODULE_FIRMWARE(FIRMWARE_NAME);
diff --git a/drivers/staging/vt6656/power.c b/drivers/staging/vt6656/power.c
deleted file mode 100644
index e5411f6284c7..000000000000
--- a/drivers/staging/vt6656/power.c
+++ /dev/null
@@ -1,112 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * Purpose: Handles 802.11 power management functions
- *
- * Author: Lyndon Chen
- *
- * Date: July 17, 2002
- *
- * Functions:
- *      vnt_enable_power_saving - Enable Power Saving Mode
- *      PSvDiasblePowerSaving - Disable Power Saving Mode
- *      vnt_next_tbtt_wakeup - Decide if we need to wake up at next Beacon
- *
- * Revision History:
- *
- */
-
-#include "mac.h"
-#include "device.h"
-#include "power.h"
-#include "wcmd.h"
-#include "rxtx.h"
-#include "card.h"
-#include "usbpipe.h"
-
-/*
- *
- * Routine Description:
- * Enable hw power saving functions
- *
- * Return Value:
- *    None.
- *
- */
-
-void vnt_enable_power_saving(struct vnt_private *priv, u16 listen_interval)
-{
-	u16 aid = priv->current_aid | BIT(14) | BIT(15);
-
-	/* set period of power up before TBTT */
-	vnt_mac_write_word(priv, MAC_REG_PWBT, C_PWBT);
-
-	if (priv->op_mode != NL80211_IFTYPE_ADHOC)
-		/* set AID */
-		vnt_mac_write_word(priv, MAC_REG_AIDATIM, aid);
-
-	/* Warren:06-18-2004,the sequence must follow
-	 * PSEN->AUTOSLEEP->GO2DOZE
-	 */
-	/* enable power saving hw function */
-	vnt_mac_reg_bits_on(priv, MAC_REG_PSCTL, PSCTL_PSEN);
-
-	/* Set AutoSleep */
-	vnt_mac_reg_bits_on(priv, MAC_REG_PSCFG, PSCFG_AUTOSLEEP);
-
-	/* Warren:MUST turn on this once before turn on AUTOSLEEP ,or the
-	 * AUTOSLEEP doesn't work
-	 */
-	vnt_mac_reg_bits_on(priv, MAC_REG_PSCTL, PSCTL_GO2DOZE);
-
-	/* always listen beacon */
-	vnt_mac_reg_bits_on(priv, MAC_REG_PSCTL, PSCTL_ALBCN);
-
-	dev_dbg(&priv->usb->dev,  "PS:Power Saving Mode Enable...\n");
-}
-
-int vnt_disable_power_saving(struct vnt_private *priv)
-{
-	int ret;
-
-	/* disable power saving hw function */
-	ret = vnt_control_out(priv, MESSAGE_TYPE_DISABLE_PS, 0,
-			      0, 0, NULL);
-	if (ret)
-		return ret;
-
-	/* clear AutoSleep */
-	vnt_mac_reg_bits_off(priv, MAC_REG_PSCFG, PSCFG_AUTOSLEEP);
-
-	/* set always listen beacon */
-	vnt_mac_reg_bits_on(priv, MAC_REG_PSCTL, PSCTL_ALBCN);
-
-	return 0;
-}
-
-/*
- *
- * Routine Description:
- * Check if Next TBTT must wake up
- *
- * Return Value:
- *    None.
- *
- */
-
-int vnt_next_tbtt_wakeup(struct vnt_private *priv)
-{
-	struct ieee80211_hw *hw = priv->hw;
-	struct ieee80211_conf *conf = &hw->conf;
-	int wake_up = false;
-
-	if (conf->listen_interval > 1) {
-		/* Turn on wake up to listen next beacon */
-		vnt_mac_reg_bits_on(priv, MAC_REG_PSCTL, PSCTL_LNBCN);
-		wake_up = true;
-	}
-
-	return wake_up;
-}
diff --git a/drivers/staging/vt6656/power.h b/drivers/staging/vt6656/power.h
deleted file mode 100644
index 9f9c70072933..000000000000
--- a/drivers/staging/vt6656/power.h
+++ /dev/null
@@ -1,23 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * Purpose: Handles 802.11 power management  functions
- *
- * Author: Lyndon Chen
- *
- * Date: July 17, 2002
- *
- */
-
-#ifndef __POWER_H__
-#define __POWER_H__
-
-#define C_PWBT	1000 /* micro sec. power up before TBTT */
-
-int vnt_disable_power_saving(struct vnt_private *priv);
-void vnt_enable_power_saving(struct vnt_private *priv, u16 listen_interval);
-int vnt_next_tbtt_wakeup(struct vnt_private *priv);
-
-#endif /* __POWER_H__ */
diff --git a/drivers/staging/vt6656/rf.c b/drivers/staging/vt6656/rf.c
deleted file mode 100644
index 464602c74727..000000000000
--- a/drivers/staging/vt6656/rf.c
+++ /dev/null
@@ -1,443 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * Purpose: rf function code
- *
- * Author: Jerry Chen
- *
- * Date: Feb. 19, 2004
- *
- * Functions:
- *	vnt_rf_write_embedded	- Embedded write RF register via MAC
- *
- * Revision History:
- *	RF_VT3226: RobertYu:20051111, VT3226C0 and before
- *	RF_VT3226D0: RobertYu:20051228
- *	RF_VT3342A0: RobertYu:20060609
- *
- */
-
-#include <linux/errno.h>
-#include "mac.h"
-#include "rf.h"
-#include "baseband.h"
-#include "usbpipe.h"
-
-#define CB_AL2230_INIT_SEQ    15
-#define CB_AL7230_INIT_SEQ    16
-#define CB_VT3226_INIT_SEQ    11
-#define CB_VT3342_INIT_SEQ    13
-
-static u8 al2230_init_table[CB_AL2230_INIT_SEQ][3] = {
-	{0x03, 0xf7, 0x90},
-	{0x03, 0x33, 0x31},
-	{0x01, 0xb8, 0x02},
-	{0x00, 0xff, 0xf3},
-	{0x00, 0x05, 0xa4},
-	{0x0f, 0x4d, 0xc5},
-	{0x08, 0x05, 0xb6},
-	{0x01, 0x47, 0xc7},
-	{0x00, 0x06, 0x88},
-	{0x04, 0x03, 0xb9},
-	{0x00, 0xdb, 0xba},
-	{0x00, 0x09, 0x9b},
-	{0x0b, 0xdf, 0xfc},
-	{0x00, 0x00, 0x0d},
-	{0x00, 0x58, 0x0f}
-};
-
-static u8 al2230_channel_table0[CB_MAX_CHANNEL_24G][3] = {
-	{0x03, 0xf7, 0x90},
-	{0x03, 0xf7, 0x90},
-	{0x03, 0xe7, 0x90},
-	{0x03, 0xe7, 0x90},
-	{0x03, 0xf7, 0xa0},
-	{0x03, 0xf7, 0xa0},
-	{0x03, 0xe7, 0xa0},
-	{0x03, 0xe7, 0xa0},
-	{0x03, 0xf7, 0xb0},
-	{0x03, 0xf7, 0xb0},
-	{0x03, 0xe7, 0xb0},
-	{0x03, 0xe7, 0xb0},
-	{0x03, 0xf7, 0xc0},
-	{0x03, 0xe7, 0xc0}
-};
-
-static u8 al2230_channel_table1[CB_MAX_CHANNEL_24G][3] = {
-	{0x03, 0x33, 0x31},
-	{0x0b, 0x33, 0x31},
-	{0x03, 0x33, 0x31},
-	{0x0b, 0x33, 0x31},
-	{0x03, 0x33, 0x31},
-	{0x0b, 0x33, 0x31},
-	{0x03, 0x33, 0x31},
-	{0x0b, 0x33, 0x31},
-	{0x03, 0x33, 0x31},
-	{0x0b, 0x33, 0x31},
-	{0x03, 0x33, 0x31},
-	{0x0b, 0x33, 0x31},
-	{0x03, 0x33, 0x31},
-	{0x06, 0x66, 0x61}
-};
-
-static u8 vt3226_init_table[CB_VT3226_INIT_SEQ][3] = {
-	{0x03, 0xff, 0x80},
-	{0x02, 0x82, 0xa1},
-	{0x03, 0xc6, 0xa2},
-	{0x01, 0x97, 0x93},
-	{0x03, 0x66, 0x64},
-	{0x00, 0x61, 0xa5},
-	{0x01, 0x7b, 0xd6},
-	{0x00, 0x80, 0x17},
-	{0x03, 0xf8, 0x08},
-	{0x00, 0x02, 0x39},
-	{0x02, 0x00, 0x2a}
-};
-
-static u8 vt3226d0_init_table[CB_VT3226_INIT_SEQ][3] = {
-	{0x03, 0xff, 0x80},
-	{0x03, 0x02, 0x21},
-	{0x03, 0xc6, 0xa2},
-	{0x01, 0x97, 0x93},
-	{0x03, 0x66, 0x64},
-	{0x00, 0x71, 0xa5},
-	{0x01, 0x15, 0xc6},
-	{0x01, 0x2e, 0x07},
-	{0x00, 0x58, 0x08},
-	{0x00, 0x02, 0x79},
-	{0x02, 0x01, 0xaa}
-};
-
-static u8 vt3226_channel_table0[CB_MAX_CHANNEL_24G][3] = {
-	{0x01, 0x97, 0x83},
-	{0x01, 0x97, 0x83},
-	{0x01, 0x97, 0x93},
-	{0x01, 0x97, 0x93},
-	{0x01, 0x97, 0x93},
-	{0x01, 0x97, 0x93},
-	{0x01, 0x97, 0xa3},
-	{0x01, 0x97, 0xa3},
-	{0x01, 0x97, 0xa3},
-	{0x01, 0x97, 0xa3},
-	{0x01, 0x97, 0xb3},
-	{0x01, 0x97, 0xb3},
-	{0x01, 0x97, 0xb3},
-	{0x03, 0x37, 0xc3}
-};
-
-static u8 vt3226_channel_table1[CB_MAX_CHANNEL_24G][3] = {
-	{0x02, 0x66, 0x64},
-	{0x03, 0x66, 0x64},
-	{0x00, 0x66, 0x64},
-	{0x01, 0x66, 0x64},
-	{0x02, 0x66, 0x64},
-	{0x03, 0x66, 0x64},
-	{0x00, 0x66, 0x64},
-	{0x01, 0x66, 0x64},
-	{0x02, 0x66, 0x64},
-	{0x03, 0x66, 0x64},
-	{0x00, 0x66, 0x64},
-	{0x01, 0x66, 0x64},
-	{0x02, 0x66, 0x64},
-	{0x00, 0xcc, 0xc4}
-};
-
-static const u32 vt3226d0_lo_current_table[CB_MAX_CHANNEL_24G] = {
-	0x0135c600,
-	0x0135c600,
-	0x0235c600,
-	0x0235c600,
-	0x0235c600,
-	0x0335c600,
-	0x0335c600,
-	0x0335c600,
-	0x0335c600,
-	0x0335c600,
-	0x0335c600,
-	0x0335c600,
-	0x0335c600,
-	0x0135c600
-};
-
-enum {
-	VNT_TABLE_INIT = 0,
-	VNT_TABLE_INIT_2 = 0,
-	VNT_TABLE_0 = 1,
-	VNT_TABLE_1 = 2,
-	VNT_TABLE_2 = 1
-};
-
-struct vnt_table_info {
-	u8 *addr;
-	int length;
-};
-
-static const struct vnt_table_info vnt_table_seq[][3] = {
-	{	/* RF_AL2230, RF_AL2230S init table, channel table 0 and 1 */
-		{&al2230_init_table[0][0], CB_AL2230_INIT_SEQ * 3},
-		{&al2230_channel_table0[0][0], CB_MAX_CHANNEL_24G * 3},
-		{&al2230_channel_table1[0][0], CB_MAX_CHANNEL_24G * 3}
-	}, {	/* RF_VT3226 init table, channel table 0 and 1 */
-		{&vt3226_init_table[0][0], CB_VT3226_INIT_SEQ * 3},
-		{&vt3226_channel_table0[0][0], CB_MAX_CHANNEL_24G * 3},
-		{&vt3226_channel_table1[0][0], CB_MAX_CHANNEL_24G * 3}
-	}, {	/* RF_VT3226D0 init table, channel table 0 and 1 */
-		{&vt3226d0_init_table[0][0], CB_VT3226_INIT_SEQ * 3},
-		{&vt3226_channel_table0[0][0], CB_MAX_CHANNEL_24G * 3},
-		{&vt3226_channel_table1[0][0], CB_MAX_CHANNEL_24G * 3}
-	}
-};
-
-/*
- * Description: Write to IF/RF, by embedded programming
- */
-int vnt_rf_write_embedded(struct vnt_private *priv, u32 data)
-{
-	u8 reg_data[4];
-
-	data |= (VNT_RF_REG_LEN << 3) | IFREGCTL_REGW;
-
-	reg_data[0] = (u8)data;
-	reg_data[1] = (u8)(data >> 8);
-	reg_data[2] = (u8)(data >> 16);
-	reg_data[3] = (u8)(data >> 24);
-
-	return vnt_control_out(priv, MESSAGE_TYPE_WRITE_IFRF, 0, 0,
-			       ARRAY_SIZE(reg_data), reg_data);
-}
-
-static u8 vnt_rf_addpower(struct vnt_private *priv)
-{
-	int base;
-	s32 rssi = -priv->current_rssi;
-
-	if (!rssi)
-		return 7;
-
-	if (priv->rf_type == RF_VT3226D0)
-		base = -60;
-	else
-		base = -70;
-
-	if (rssi < base)
-		return ((rssi - base + 1) / -5) * 2 + 5;
-
-	return 0;
-}
-
-/* Set Tx power by power level and rate */
-static int vnt_rf_set_txpower(struct vnt_private *priv, u8 power,
-			      struct ieee80211_channel *ch)
-{
-	u32 power_setting = 0;
-	int ret = 0;
-
-	power += vnt_rf_addpower(priv);
-	if (power > VNT_RF_MAX_POWER)
-		power = VNT_RF_MAX_POWER;
-
-	if (priv->power == power)
-		return 0;
-
-	priv->power = power;
-
-	switch (priv->rf_type) {
-	case RF_AL2230:
-		power_setting = 0x0404090 | (power << 12);
-
-		ret = vnt_rf_write_embedded(priv, power_setting);
-		if (ret)
-			return ret;
-
-		if (ch->flags & IEEE80211_CHAN_NO_OFDM)
-			ret = vnt_rf_write_embedded(priv, 0x0001b400);
-		else
-			ret = vnt_rf_write_embedded(priv, 0x0005a400);
-
-		break;
-	case RF_AL2230S:
-		power_setting = 0x0404090 | (power << 12);
-
-		ret = vnt_rf_write_embedded(priv, power_setting);
-		if (ret)
-			return ret;
-
-		if (ch->flags & IEEE80211_CHAN_NO_OFDM) {
-			ret = vnt_rf_write_embedded(priv, 0x040c1400);
-			if (ret)
-				return ret;
-
-			ret = vnt_rf_write_embedded(priv, 0x00299b00);
-		} else {
-			ret = vnt_rf_write_embedded(priv, 0x0005a400);
-			if (ret)
-				return ret;
-
-			ret = vnt_rf_write_embedded(priv, 0x00099b00);
-		}
-
-		break;
-
-	case RF_VT3226:
-		power_setting = ((0x3f - power) << 20) | (0x17 << 8);
-
-		ret = vnt_rf_write_embedded(priv, power_setting);
-		break;
-	case RF_VT3226D0:
-		if (ch->flags & IEEE80211_CHAN_NO_OFDM) {
-			u16 hw_value = ch->hw_value;
-
-			power_setting = ((0x3f - power) << 20) | (0xe07 << 8);
-
-			ret = vnt_rf_write_embedded(priv, power_setting);
-			if (ret)
-				return ret;
-
-			ret = vnt_rf_write_embedded(priv, 0x03c6a200);
-			if (ret)
-				return ret;
-
-			dev_dbg(&priv->usb->dev,
-				"%s 11b channel [%d]\n", __func__, hw_value);
-
-			hw_value--;
-
-			if (hw_value < ARRAY_SIZE(vt3226d0_lo_current_table)) {
-				ret = vnt_rf_write_embedded(priv,
-							    vt3226d0_lo_current_table[hw_value]);
-				if (ret)
-					return ret;
-			}
-
-			ret = vnt_rf_write_embedded(priv, 0x015C0800);
-		} else {
-			dev_dbg(&priv->usb->dev,
-				"@@@@ %s> 11G mode\n", __func__);
-
-			power_setting = ((0x3f - power) << 20) | (0x7 << 8);
-
-			ret = vnt_rf_write_embedded(priv, power_setting);
-			if (ret)
-				return ret;
-
-			ret = vnt_rf_write_embedded(priv, 0x00C6A200);
-			if (ret)
-				return ret;
-
-			ret = vnt_rf_write_embedded(priv, 0x016BC600);
-			if (ret)
-				return ret;
-
-			ret = vnt_rf_write_embedded(priv, 0x00900800);
-		}
-
-		break;
-
-	default:
-		break;
-	}
-	return ret;
-}
-
-/* Set Tx power by channel number type */
-int vnt_rf_setpower(struct vnt_private *priv,
-		    struct ieee80211_channel *ch)
-{
-	u16 channel;
-	u8 power = priv->cck_pwr;
-
-	if (!ch)
-		return -EINVAL;
-
-	/* set channel number to array number */
-	channel = ch->hw_value - 1;
-
-	if (ch->flags & IEEE80211_CHAN_NO_OFDM) {
-		if (channel < ARRAY_SIZE(priv->cck_pwr_tbl))
-			power = priv->cck_pwr_tbl[channel];
-	} else if (ch->band == NL80211_BAND_5GHZ) {
-		/* remove 14 channels to array size */
-		channel -= 14;
-
-		if (channel < ARRAY_SIZE(priv->ofdm_a_pwr_tbl))
-			power = priv->ofdm_a_pwr_tbl[channel];
-	} else {
-		if (channel < ARRAY_SIZE(priv->ofdm_pwr_tbl))
-			power = priv->ofdm_pwr_tbl[channel];
-	}
-
-	return vnt_rf_set_txpower(priv, power, ch);
-}
-
-/* Convert rssi to dbm */
-void vnt_rf_rssi_to_dbm(struct vnt_private *priv, u8 rssi, long *dbm)
-{
-	u8 idx = ((rssi & 0xc0) >> 6) & 0x03;
-	long b = rssi & 0x3f;
-	long a = 0;
-	u8 airoharf[4] = {0, 18, 0, 40};
-
-	switch (priv->rf_type) {
-	case RF_AL2230:
-	case RF_AL2230S:
-	case RF_VT3226:
-	case RF_VT3226D0:
-		a = airoharf[idx];
-		break;
-	default:
-		break;
-	}
-
-	*dbm = -1 * (a + b * 2);
-}
-
-int vnt_rf_table_download(struct vnt_private *priv)
-{
-	int ret;
-	int idx = -1;
-	const struct vnt_table_info *table_seq;
-
-	switch (priv->rf_type) {
-	case RF_AL2230:
-	case RF_AL2230S:
-		idx = 0;
-		break;
-	case RF_VT3226:
-		idx = 1;
-		break;
-	case RF_VT3226D0:
-		idx = 2;
-		break;
-	}
-
-	if (idx < 0)
-		return 0;
-
-	table_seq = &vnt_table_seq[idx][0];
-
-	/* Init Table */
-	ret = vnt_control_out(priv, MESSAGE_TYPE_WRITE, 0,
-			      MESSAGE_REQUEST_RF_INIT,
-			      table_seq[VNT_TABLE_INIT].length,
-			      table_seq[VNT_TABLE_INIT].addr);
-	if (ret)
-		return ret;
-
-	/* Channel Table 0 */
-	ret = vnt_control_out_blocks(priv, VNT_REG_BLOCK_SIZE,
-				     MESSAGE_REQUEST_RF_CH0,
-				     table_seq[VNT_TABLE_0].length,
-				     table_seq[VNT_TABLE_0].addr);
-	if (ret)
-		return ret;
-
-	/* Channel Table 1 */
-	ret = vnt_control_out_blocks(priv, VNT_REG_BLOCK_SIZE,
-				     MESSAGE_REQUEST_RF_CH1,
-				     table_seq[VNT_TABLE_1].length,
-				     table_seq[VNT_TABLE_1].addr);
-
-	return ret;
-}
diff --git a/drivers/staging/vt6656/rf.h b/drivers/staging/vt6656/rf.h
deleted file mode 100644
index b47e149875d1..000000000000
--- a/drivers/staging/vt6656/rf.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * Purpose:
- *
- * Author: Jerry Chen
- *
- * Date: Feb. 19, 2004
- *
- */
-
-#ifndef __RF_H__
-#define __RF_H__
-
-#include "device.h"
-
-/* Baseband RF pair definition in eeprom (Bits 6..0) */
-#define RF_RFMD2959         0x01
-#define RF_MAXIMAG          0x02
-#define RF_AL2230           0x03
-#define RF_GCT5103          0x04
-#define RF_UW2451           0x05
-#define RF_MAXIMG           0x06
-#define RF_MAXIM2829        0x07
-#define RF_UW2452           0x08
-#define RF_VT3226           0x09
-#define RF_AIROHA7230       0x0a
-#define RF_UW2453           0x0b
-#define RF_VT3226D0         0x0c /* RobertYu:20051114 */
-#define RF_VT3342A0         0x0d /* RobertYu:20060609 */
-#define RF_AL2230S          0x0e
-
-#define RF_EMU              0x80
-#define RF_MASK             0x7F
-
-#define VNT_RF_MAX_POWER    0x3f
-#define	VNT_RF_REG_LEN      0x17 /* 24 bit length */
-
-int vnt_rf_write_embedded(struct vnt_private *priv, u32 data);
-int vnt_rf_setpower(struct vnt_private *priv, struct ieee80211_channel *ch);
-void vnt_rf_rssi_to_dbm(struct vnt_private *priv, u8 rssi, long *dbm);
-int vnt_rf_table_download(struct vnt_private *priv);
-
-#endif /* __RF_H__ */
diff --git a/drivers/staging/vt6656/rxtx.c b/drivers/staging/vt6656/rxtx.c
deleted file mode 100644
index cd99091c6c28..000000000000
--- a/drivers/staging/vt6656/rxtx.c
+++ /dev/null
@@ -1,730 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * Purpose: handle WMAC/802.3/802.11 rx & tx functions
- *
- * Author: Lyndon Chen
- *
- * Date: May 20, 2003
- *
- * Functions:
- *      vnt_generate_tx_parameter - Generate tx dma required parameter.
- *      vnt_get_rsvtime- get frame reserved time
- *      vnt_fill_cts_head- fulfill CTS ctl header
- *
- * Revision History:
- *
- */
-
-#include <linux/etherdevice.h>
-#include "device.h"
-#include "rxtx.h"
-#include "card.h"
-#include "mac.h"
-#include "rf.h"
-#include "usbpipe.h"
-
-static const u16 vnt_time_stampoff[2][MAX_RATE] = {
-	/* Long Preamble */
-	{384, 288, 226, 209, 54, 43, 37, 31, 28, 25, 24, 23},
-
-	/* Short Preamble */
-	{384, 192, 130, 113, 54, 43, 37, 31, 28, 25, 24, 23},
-};
-
-#define DATADUR_B       10
-#define DATADUR_A       11
-
-static const u8 vnt_phy_signal[] = {
-	0x00,	/* RATE_1M  */
-	0x01,	/* RATE_2M  */
-	0x02,	/* RATE_5M  */
-	0x03,	/* RATE_11M */
-	0x8b,	/* RATE_6M  */
-	0x8f,	/* RATE_9M  */
-	0x8a,	/* RATE_12M */
-	0x8e,	/* RATE_18M */
-	0x89,	/* RATE_24M */
-	0x8d,	/* RATE_36M */
-	0x88,	/* RATE_48M */
-	0x8c	/* RATE_54M */
-};
-
-static struct vnt_usb_send_context
-	*vnt_get_free_context(struct vnt_private *priv)
-{
-	struct vnt_usb_send_context *context = NULL;
-	int ii;
-
-	for (ii = 0; ii < priv->num_tx_context; ii++) {
-		if (!priv->tx_context[ii])
-			return NULL;
-
-		context = priv->tx_context[ii];
-		if (!context->in_use) {
-			context->in_use = true;
-			return context;
-		}
-	}
-
-	if (ii == priv->num_tx_context) {
-		dev_dbg(&priv->usb->dev, "%s No Free Tx Context\n", __func__);
-
-		ieee80211_stop_queues(priv->hw);
-	}
-
-	return NULL;
-}
-
-/* Get Length, Service, and Signal fields of Phy for Tx */
-static void vnt_get_phy_field(struct vnt_private *priv, u32 frame_length,
-			      u16 tx_rate, u8 pkt_type,
-			      struct vnt_phy_field *phy)
-{
-	u32 bit_count;
-	u32 count = 0;
-	u32 tmp;
-	int ext_bit;
-	int i;
-	u8 mask = 0;
-	u8 preamble_type = priv->preamble_type;
-
-	bit_count = frame_length * 8;
-	ext_bit = false;
-
-	switch (tx_rate) {
-	case RATE_1M:
-		count = bit_count;
-		break;
-	case RATE_2M:
-		count = bit_count / 2;
-		break;
-	case RATE_5M:
-		count = DIV_ROUND_UP(bit_count * 10, 55);
-		break;
-	case RATE_11M:
-		count = bit_count / 11;
-		tmp = count * 11;
-
-		if (tmp != bit_count) {
-			count++;
-
-			if ((bit_count - tmp) <= 3)
-				ext_bit = true;
-		}
-
-		break;
-	}
-
-	if (tx_rate > RATE_11M) {
-		if (pkt_type == PK_TYPE_11A)
-			mask = BIT(4);
-	} else if (tx_rate > RATE_1M) {
-		if (preamble_type == PREAMBLE_SHORT)
-			mask = BIT(3);
-	}
-
-	i = tx_rate > RATE_54M ? RATE_54M : tx_rate;
-	phy->signal = vnt_phy_signal[i] | mask;
-	phy->service = 0x00;
-
-	if (pkt_type == PK_TYPE_11B) {
-		if (ext_bit)
-			phy->service |= 0x80;
-		phy->len = cpu_to_le16((u16)count);
-	} else {
-		phy->len = cpu_to_le16((u16)frame_length);
-	}
-}
-
-static __le16 vnt_time_stamp_off(struct vnt_private *priv, u16 rate)
-{
-	return cpu_to_le16(vnt_time_stampoff[priv->preamble_type % 2]
-							[rate % MAX_RATE]);
-}
-
-static __le16 vnt_rxtx_rsvtime_le16(struct vnt_usb_send_context *context)
-{
-	struct vnt_private *priv = context->priv;
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(context->skb);
-	struct ieee80211_rate *rate = ieee80211_get_tx_rate(priv->hw, info);
-
-	return ieee80211_generic_frame_duration(priv->hw,
-						 info->control.vif, info->band,
-						 context->frame_len,
-						 rate);
-}
-
-static __le16 vnt_get_rts_duration(struct vnt_usb_send_context *context)
-{
-	struct vnt_private *priv = context->priv;
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(context->skb);
-
-	return ieee80211_rts_duration(priv->hw, priv->vif,
-				      context->frame_len, info);
-}
-
-static __le16 vnt_get_cts_duration(struct vnt_usb_send_context *context)
-{
-	struct vnt_private *priv = context->priv;
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(context->skb);
-
-	return ieee80211_ctstoself_duration(priv->hw, priv->vif,
-					    context->frame_len, info);
-}
-
-static void vnt_rxtx_datahead_g(struct vnt_usb_send_context *tx_context,
-				struct vnt_tx_datahead_g *buf)
-{
-	struct vnt_private *priv = tx_context->priv;
-	struct ieee80211_hdr *hdr =
-				(struct ieee80211_hdr *)tx_context->skb->data;
-	u32 frame_len = tx_context->frame_len;
-	u16 rate = tx_context->tx_rate;
-
-	/* Get SignalField,ServiceField,Length */
-	vnt_get_phy_field(priv, frame_len, rate, tx_context->pkt_type, &buf->a);
-	vnt_get_phy_field(priv, frame_len, priv->top_cck_basic_rate,
-			  PK_TYPE_11B, &buf->b);
-
-	/* Get Duration and TimeStamp */
-	buf->duration_a = hdr->duration_id;
-	buf->duration_b = hdr->duration_id;
-	buf->time_stamp_off_a = vnt_time_stamp_off(priv, rate);
-	buf->time_stamp_off_b = vnt_time_stamp_off(priv,
-						   priv->top_cck_basic_rate);
-}
-
-static void vnt_rxtx_datahead_ab(struct vnt_usb_send_context *tx_context,
-				 struct vnt_tx_datahead_ab *buf)
-{
-	struct vnt_private *priv = tx_context->priv;
-	struct ieee80211_hdr *hdr =
-				(struct ieee80211_hdr *)tx_context->skb->data;
-	u32 frame_len = tx_context->frame_len;
-	u16 rate = tx_context->tx_rate;
-
-	/* Get SignalField,ServiceField,Length */
-	vnt_get_phy_field(priv, frame_len, rate,
-			  tx_context->pkt_type, &buf->ab);
-
-	/* Get Duration and TimeStampOff */
-	buf->duration = hdr->duration_id;
-	buf->time_stamp_off = vnt_time_stamp_off(priv, rate);
-}
-
-static void vnt_fill_ieee80211_rts(struct vnt_usb_send_context *tx_context,
-				   struct ieee80211_rts *rts, __le16 duration)
-{
-	struct ieee80211_hdr *hdr =
-				(struct ieee80211_hdr *)tx_context->skb->data;
-
-	rts->duration = duration;
-	rts->frame_control =
-		cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_RTS);
-
-	ether_addr_copy(rts->ra, hdr->addr1);
-	ether_addr_copy(rts->ta, hdr->addr2);
-}
-
-static void vnt_rxtx_rts_g_head(struct vnt_usb_send_context *tx_context,
-				struct vnt_rts_g *buf)
-{
-	struct vnt_private *priv = tx_context->priv;
-	u16 rts_frame_len = 20;
-
-	vnt_get_phy_field(priv, rts_frame_len, priv->top_cck_basic_rate,
-			  PK_TYPE_11B, &buf->b);
-	vnt_get_phy_field(priv, rts_frame_len, priv->top_ofdm_basic_rate,
-			  tx_context->pkt_type, &buf->a);
-
-	buf->duration_bb = vnt_get_rts_duration(tx_context);
-	buf->duration_aa = buf->duration_bb;
-	buf->duration_ba = buf->duration_bb;
-
-	vnt_fill_ieee80211_rts(tx_context, &buf->data, buf->duration_aa);
-
-	vnt_rxtx_datahead_g(tx_context, &buf->data_head);
-}
-
-static void vnt_rxtx_rts_ab_head(struct vnt_usb_send_context *tx_context,
-				 struct vnt_rts_ab *buf)
-{
-	struct vnt_private *priv = tx_context->priv;
-	u16 rts_frame_len = 20;
-
-	vnt_get_phy_field(priv, rts_frame_len, priv->top_ofdm_basic_rate,
-			  tx_context->pkt_type, &buf->ab);
-
-	buf->duration = vnt_get_rts_duration(tx_context);
-
-	vnt_fill_ieee80211_rts(tx_context, &buf->data, buf->duration);
-
-	vnt_rxtx_datahead_ab(tx_context, &buf->data_head);
-}
-
-static void vnt_fill_cts_head(struct vnt_usb_send_context *tx_context,
-			      union vnt_tx_data_head *head)
-{
-	struct vnt_private *priv = tx_context->priv;
-	struct vnt_cts *buf = &head->cts_g;
-	u32 cts_frame_len = 14;
-
-	/* Get SignalField,ServiceField,Length */
-	vnt_get_phy_field(priv, cts_frame_len, priv->top_cck_basic_rate,
-			  PK_TYPE_11B, &buf->b);
-	/* Get CTSDuration_ba */
-	buf->duration_ba = vnt_get_cts_duration(tx_context);
-	/*Get CTS Frame body*/
-	buf->data.duration = buf->duration_ba;
-	buf->data.frame_control =
-		cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_CTS);
-
-	ether_addr_copy(buf->data.ra, priv->current_net_addr);
-
-	vnt_rxtx_datahead_g(tx_context, &buf->data_head);
-}
-
-/* returns true if mic_hdr is needed */
-static bool vnt_fill_txkey(struct vnt_tx_buffer *tx_buffer, struct sk_buff *skb)
-{
-	struct vnt_tx_fifo_head *fifo = &tx_buffer->fifo_head;
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
-	struct ieee80211_key_conf *tx_key = info->control.hw_key;
-	struct vnt_mic_hdr *mic_hdr;
-	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
-	u64 pn64;
-	u16 payload_len = skb->len;
-	u8 *iv = ((u8 *)hdr + ieee80211_get_hdrlen_from_skb(skb));
-
-	/* strip header and icv len from payload */
-	payload_len -= ieee80211_get_hdrlen_from_skb(skb);
-	payload_len -= tx_key->icv_len;
-
-	switch (tx_key->cipher) {
-	case WLAN_CIPHER_SUITE_WEP40:
-	case WLAN_CIPHER_SUITE_WEP104:
-		memcpy(fifo->tx_key, iv, 3);
-		memcpy(fifo->tx_key + 3, tx_key->key, tx_key->keylen);
-
-		if (tx_key->keylen == WLAN_KEY_LEN_WEP40) {
-			memcpy(fifo->tx_key + 8, iv, 3);
-			memcpy(fifo->tx_key + 11,
-			       tx_key->key, WLAN_KEY_LEN_WEP40);
-		}
-
-		fifo->frag_ctl |= cpu_to_le16(FRAGCTL_LEGACY);
-		break;
-	case WLAN_CIPHER_SUITE_TKIP:
-		ieee80211_get_tkip_p2k(tx_key, skb, fifo->tx_key);
-
-		fifo->frag_ctl |= cpu_to_le16(FRAGCTL_TKIP);
-		break;
-	case WLAN_CIPHER_SUITE_CCMP:
-		if (info->control.use_cts_prot) {
-			if (info->control.use_rts)
-				mic_hdr = &tx_buffer->tx_head.tx_rts.tx.mic.hdr;
-			else
-				mic_hdr = &tx_buffer->tx_head.tx_cts.tx.mic.hdr;
-		} else {
-			mic_hdr = &tx_buffer->tx_head.tx_ab.tx.mic.hdr;
-		}
-
-		mic_hdr->id = 0x59;
-		mic_hdr->payload_len = cpu_to_be16(payload_len);
-		ether_addr_copy(mic_hdr->mic_addr2, hdr->addr2);
-
-		pn64 = atomic64_read(&tx_key->tx_pn);
-		mic_hdr->ccmp_pn[5] = pn64;
-		mic_hdr->ccmp_pn[4] = pn64 >> 8;
-		mic_hdr->ccmp_pn[3] = pn64 >> 16;
-		mic_hdr->ccmp_pn[2] = pn64 >> 24;
-		mic_hdr->ccmp_pn[1] = pn64 >> 32;
-		mic_hdr->ccmp_pn[0] = pn64 >> 40;
-
-		if (ieee80211_has_a4(hdr->frame_control))
-			mic_hdr->hlen = cpu_to_be16(28);
-		else
-			mic_hdr->hlen = cpu_to_be16(22);
-
-		ether_addr_copy(mic_hdr->addr1, hdr->addr1);
-		ether_addr_copy(mic_hdr->addr2, hdr->addr2);
-		ether_addr_copy(mic_hdr->addr3, hdr->addr3);
-
-		mic_hdr->frame_control = cpu_to_le16(le16_to_cpu(hdr->frame_control) & 0xc78f);
-		mic_hdr->seq_ctrl = cpu_to_le16(le16_to_cpu(hdr->seq_ctrl) & 0xf);
-
-		if (ieee80211_has_a4(hdr->frame_control))
-			ether_addr_copy(mic_hdr->addr4, hdr->addr4);
-
-		memcpy(fifo->tx_key, tx_key->key, WLAN_KEY_LEN_CCMP);
-
-		fifo->frag_ctl |= cpu_to_le16(FRAGCTL_AES);
-		return true;
-	default:
-		break;
-	}
-
-	return false;
-}
-
-static void vnt_rxtx_rts(struct vnt_usb_send_context *tx_context)
-{
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx_context->skb);
-	struct vnt_tx_buffer *tx_buffer = tx_context->tx_buffer;
-	union vnt_tx_head *tx_head = &tx_buffer->tx_head;
-	struct vnt_rrv_time_rts *buf = &tx_head->tx_rts.rts;
-	union vnt_tx_data_head *head = &tx_head->tx_rts.tx.head;
-
-	buf->rts_rrv_time_aa = vnt_get_rts_duration(tx_context);
-	buf->rts_rrv_time_ba = buf->rts_rrv_time_aa;
-	buf->rts_rrv_time_bb = buf->rts_rrv_time_aa;
-
-	buf->rrv_time_a = vnt_rxtx_rsvtime_le16(tx_context);
-	buf->rrv_time_b = buf->rrv_time_a;
-
-	if (info->control.hw_key) {
-		if (vnt_fill_txkey(tx_buffer, tx_context->skb))
-			head = &tx_head->tx_rts.tx.mic.head;
-	}
-
-	vnt_rxtx_rts_g_head(tx_context, &head->rts_g);
-}
-
-static void vnt_rxtx_cts(struct vnt_usb_send_context *tx_context)
-{
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx_context->skb);
-	struct vnt_tx_buffer *tx_buffer = tx_context->tx_buffer;
-	union vnt_tx_head *tx_head = &tx_buffer->tx_head;
-	struct vnt_rrv_time_cts *buf = &tx_head->tx_cts.cts;
-	union vnt_tx_data_head *head = &tx_head->tx_cts.tx.head;
-
-	buf->rrv_time_a = vnt_rxtx_rsvtime_le16(tx_context);
-	buf->rrv_time_b = buf->rrv_time_a;
-
-	buf->cts_rrv_time_ba = vnt_get_cts_duration(tx_context);
-
-	if (info->control.hw_key) {
-		if (vnt_fill_txkey(tx_buffer, tx_context->skb))
-			head = &tx_head->tx_cts.tx.mic.head;
-	}
-
-	vnt_fill_cts_head(tx_context, head);
-}
-
-static void vnt_rxtx_ab(struct vnt_usb_send_context *tx_context)
-{
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx_context->skb);
-	struct vnt_tx_buffer *tx_buffer = tx_context->tx_buffer;
-	union vnt_tx_head *tx_head = &tx_buffer->tx_head;
-	struct vnt_rrv_time_ab *buf = &tx_head->tx_ab.ab;
-	union vnt_tx_data_head *head = &tx_head->tx_ab.tx.head;
-
-	buf->rrv_time = vnt_rxtx_rsvtime_le16(tx_context);
-
-	if (info->control.hw_key) {
-		if (vnt_fill_txkey(tx_buffer, tx_context->skb))
-			head = &tx_head->tx_ab.tx.mic.head;
-	}
-
-	if (info->control.use_rts) {
-		buf->rts_rrv_time = vnt_get_rts_duration(tx_context);
-
-		vnt_rxtx_rts_ab_head(tx_context, &head->rts_ab);
-
-		return;
-	}
-
-	vnt_rxtx_datahead_ab(tx_context, &head->data_head_ab);
-}
-
-static void vnt_generate_tx_parameter(struct vnt_usb_send_context *tx_context)
-{
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx_context->skb);
-
-	if (info->control.use_cts_prot) {
-		if (info->control.use_rts) {
-			vnt_rxtx_rts(tx_context);
-
-			return;
-		}
-
-		vnt_rxtx_cts(tx_context);
-
-		return;
-	}
-
-	vnt_rxtx_ab(tx_context);
-}
-
-static u16 vnt_get_hdr_size(struct ieee80211_tx_info *info)
-{
-	u16 size = sizeof(struct vnt_tx_datahead_ab);
-
-	if (info->control.use_cts_prot) {
-		if (info->control.use_rts)
-			size = sizeof(struct vnt_rts_g);
-		else
-			size = sizeof(struct vnt_cts);
-	} else if (info->control.use_rts) {
-		size = sizeof(struct vnt_rts_ab);
-	}
-
-	if (info->control.hw_key) {
-		if (info->control.hw_key->cipher == WLAN_CIPHER_SUITE_CCMP)
-			size += sizeof(struct vnt_mic_hdr);
-	}
-
-	/* Get rrv_time header */
-	if (info->control.use_cts_prot) {
-		if (info->control.use_rts)
-			size += sizeof(struct vnt_rrv_time_rts);
-		else
-			size += sizeof(struct vnt_rrv_time_cts);
-	} else {
-		size += sizeof(struct vnt_rrv_time_ab);
-	}
-
-	size += sizeof(struct vnt_tx_fifo_head);
-
-	return size;
-}
-
-int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)
-{
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
-	struct ieee80211_tx_rate *tx_rate = &info->control.rates[0];
-	struct ieee80211_rate *rate;
-	struct ieee80211_hdr *hdr;
-	struct vnt_tx_buffer *tx_buffer;
-	struct vnt_tx_fifo_head *tx_buffer_head;
-	struct vnt_usb_send_context *tx_context;
-	unsigned long flags;
-	u8 pkt_type;
-
-	hdr = (struct ieee80211_hdr *)(skb->data);
-
-	rate = ieee80211_get_tx_rate(priv->hw, info);
-
-	if (rate->hw_value > RATE_11M) {
-		if (info->band == NL80211_BAND_5GHZ) {
-			pkt_type = PK_TYPE_11A;
-		} else {
-			if (tx_rate->flags & IEEE80211_TX_RC_USE_CTS_PROTECT) {
-				if (priv->basic_rates & VNT_B_RATES)
-					pkt_type = PK_TYPE_11GB;
-				else
-					pkt_type = PK_TYPE_11GA;
-			} else {
-				pkt_type = PK_TYPE_11A;
-			}
-		}
-	} else {
-		pkt_type = PK_TYPE_11B;
-	}
-
-	spin_lock_irqsave(&priv->lock, flags);
-
-	tx_context = vnt_get_free_context(priv);
-	if (!tx_context) {
-		dev_dbg(&priv->usb->dev, "%s No free context\n", __func__);
-		spin_unlock_irqrestore(&priv->lock, flags);
-		return -ENOMEM;
-	}
-
-	tx_context->pkt_type = pkt_type;
-	tx_context->frame_len = skb->len + 4;
-	tx_context->tx_rate =  rate->hw_value;
-
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	tx_context->skb = skb_clone(skb, GFP_ATOMIC);
-	if (!tx_context->skb) {
-		tx_context->in_use = false;
-		return -ENOMEM;
-	}
-
-	tx_buffer = skb_push(skb, vnt_get_hdr_size(info));
-	tx_context->tx_buffer = tx_buffer;
-	tx_buffer_head = &tx_buffer->fifo_head;
-
-	tx_context->type = CONTEXT_DATA_PACKET;
-
-	/*Set fifo controls */
-	if (pkt_type == PK_TYPE_11A)
-		tx_buffer_head->fifo_ctl = 0;
-	else if (pkt_type == PK_TYPE_11B)
-		tx_buffer_head->fifo_ctl = cpu_to_le16(FIFOCTL_11B);
-	else if (pkt_type == PK_TYPE_11GB)
-		tx_buffer_head->fifo_ctl = cpu_to_le16(FIFOCTL_11GB);
-	else if (pkt_type == PK_TYPE_11GA)
-		tx_buffer_head->fifo_ctl = cpu_to_le16(FIFOCTL_11GA);
-
-	if (!ieee80211_is_data(hdr->frame_control)) {
-		tx_buffer_head->fifo_ctl |= cpu_to_le16(FIFOCTL_GENINT |
-							FIFOCTL_ISDMA0);
-		tx_buffer_head->fifo_ctl |= cpu_to_le16(FIFOCTL_TMOEN);
-
-		tx_buffer_head->time_stamp =
-			cpu_to_le16(DEFAULT_MGN_LIFETIME_RES_64us);
-	} else {
-		tx_buffer_head->time_stamp =
-			cpu_to_le16(DEFAULT_MSDU_LIFETIME_RES_64us);
-	}
-
-	if (!(info->flags & IEEE80211_TX_CTL_NO_ACK))
-		tx_buffer_head->fifo_ctl |= cpu_to_le16(FIFOCTL_NEEDACK);
-
-	if (ieee80211_has_retry(hdr->frame_control))
-		tx_buffer_head->fifo_ctl |= cpu_to_le16(FIFOCTL_LRETRY);
-
-	if (info->control.use_rts)
-		tx_buffer_head->fifo_ctl |= cpu_to_le16(FIFOCTL_RTS);
-
-	if (ieee80211_has_a4(hdr->frame_control))
-		tx_buffer_head->fifo_ctl |= cpu_to_le16(FIFOCTL_LHEAD);
-
-	tx_buffer_head->frag_ctl =
-			cpu_to_le16(ieee80211_hdrlen(hdr->frame_control) << 10);
-
-	if (info->control.hw_key)
-		tx_context->frame_len += info->control.hw_key->icv_len;
-
-	tx_buffer_head->current_rate = cpu_to_le16(rate->hw_value);
-
-	vnt_generate_tx_parameter(tx_context);
-
-	tx_buffer_head->frag_ctl |= cpu_to_le16(FRAGCTL_NONFRAG);
-
-	priv->seq_counter = (le16_to_cpu(hdr->seq_ctrl) &
-						IEEE80211_SCTL_SEQ) >> 4;
-
-	spin_lock_irqsave(&priv->lock, flags);
-
-	if (vnt_tx_context(priv, tx_context, skb)) {
-		dev_kfree_skb(tx_context->skb);
-		spin_unlock_irqrestore(&priv->lock, flags);
-		return -EIO;
-	}
-
-	dev_kfree_skb(skb);
-
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	return 0;
-}
-
-static int vnt_beacon_xmit(struct vnt_private *priv, struct sk_buff *skb)
-{
-	struct vnt_tx_short_buf_head *short_head;
-	struct ieee80211_tx_info *info;
-	struct vnt_usb_send_context *context;
-	struct ieee80211_mgmt *mgmt_hdr;
-	unsigned long flags;
-	u32 frame_size = skb->len + 4;
-	u16 current_rate;
-
-	spin_lock_irqsave(&priv->lock, flags);
-
-	context = vnt_get_free_context(priv);
-	if (!context) {
-		dev_dbg(&priv->usb->dev, "%s No free context!\n", __func__);
-		spin_unlock_irqrestore(&priv->lock, flags);
-		return -ENOMEM;
-	}
-
-	context->skb = skb;
-
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	mgmt_hdr = (struct ieee80211_mgmt *)skb->data;
-	short_head = skb_push(skb, sizeof(*short_head));
-
-	if (priv->bb_type == BB_TYPE_11A) {
-		current_rate = RATE_6M;
-
-		/* Get SignalField,ServiceField,Length */
-		vnt_get_phy_field(priv, frame_size, current_rate,
-				  PK_TYPE_11A, &short_head->ab);
-
-		/* Get TimeStampOff */
-		short_head->time_stamp_off =
-				vnt_time_stamp_off(priv, current_rate);
-	} else {
-		current_rate = RATE_1M;
-		short_head->fifo_ctl |= cpu_to_le16(FIFOCTL_11B);
-
-		/* Get SignalField,ServiceField,Length */
-		vnt_get_phy_field(priv, frame_size, current_rate,
-				  PK_TYPE_11B, &short_head->ab);
-
-		/* Get TimeStampOff */
-		short_head->time_stamp_off =
-			vnt_time_stamp_off(priv, current_rate);
-	}
-
-	/* Get Duration */
-	short_head->duration = mgmt_hdr->duration;
-
-	/* time stamp always 0 */
-	mgmt_hdr->u.beacon.timestamp = 0;
-
-	info = IEEE80211_SKB_CB(skb);
-	if (info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ) {
-		struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)mgmt_hdr;
-
-		hdr->duration_id = 0;
-		hdr->seq_ctrl = cpu_to_le16(priv->seq_counter << 4);
-	}
-
-	priv->seq_counter++;
-	if (priv->seq_counter > 0x0fff)
-		priv->seq_counter = 0;
-
-	context->type = CONTEXT_BEACON_PACKET;
-
-	spin_lock_irqsave(&priv->lock, flags);
-
-	if (vnt_tx_context(priv, context, skb))
-		ieee80211_free_txskb(priv->hw, context->skb);
-
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	return 0;
-}
-
-int vnt_beacon_make(struct vnt_private *priv, struct ieee80211_vif *vif)
-{
-	struct sk_buff *beacon;
-
-	beacon = ieee80211_beacon_get(priv->hw, vif, 0);
-	if (!beacon)
-		return -ENOMEM;
-
-	if (vnt_beacon_xmit(priv, beacon)) {
-		ieee80211_free_txskb(priv->hw, beacon);
-		return -ENODEV;
-	}
-
-	return 0;
-}
-
-int vnt_beacon_enable(struct vnt_private *priv, struct ieee80211_vif *vif,
-		      struct ieee80211_bss_conf *conf)
-{
-	vnt_mac_reg_bits_off(priv, MAC_REG_TCR, TCR_AUTOBCNTX);
-
-	vnt_mac_reg_bits_off(priv, MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);
-
-	vnt_mac_set_beacon_interval(priv, conf->beacon_int);
-
-	vnt_clear_current_tsf(priv);
-
-	vnt_mac_reg_bits_on(priv, MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);
-
-	vnt_reset_next_tbtt(priv, conf->beacon_int);
-
-	return vnt_beacon_make(priv, vif);
-}
diff --git a/drivers/staging/vt6656/rxtx.h b/drivers/staging/vt6656/rxtx.h
deleted file mode 100644
index b9df0854b4b0..000000000000
--- a/drivers/staging/vt6656/rxtx.h
+++ /dev/null
@@ -1,178 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * Purpose:
- *
- * Author: Jerry Chen
- *
- * Date: Jun. 27, 2002
- *
- */
-
-#ifndef __RXTX_H__
-#define __RXTX_H__
-
-#include "device.h"
-#include "wcmd.h"
-#include "baseband.h"
-
-#define DEFAULT_MGN_LIFETIME_RES_64us	125  /* 64us */
-#define DEFAULT_MSDU_LIFETIME_RES_64us  8000
-
-/* Length, Service, and Signal fields of Phy for Tx */
-struct vnt_phy_field {
-	u8 signal;
-	u8 service;
-	__le16 len;
-} __packed;
-
-/* MIC HDR data header */
-struct vnt_mic_hdr {
-	u8 id;
-	u8 tx_priority;
-	u8 mic_addr2[6];
-	u8 ccmp_pn[IEEE80211_CCMP_PN_LEN];
-	__be16 payload_len;
-	__be16 hlen;
-	__le16 frame_control;
-	u8 addr1[6];
-	u8 addr2[6];
-	u8 addr3[6];
-	__le16 seq_ctrl;
-	u8 addr4[6];
-	u16 packing; /* packing to 48 bytes */
-} __packed;
-
-/* RsvTime buffer header */
-struct vnt_rrv_time_rts {
-	__le16 rts_rrv_time_ba;
-	__le16 rts_rrv_time_aa;
-	__le16 rts_rrv_time_bb;
-	u16 wReserved;
-	__le16 rrv_time_b;
-	__le16 rrv_time_a;
-} __packed;
-
-struct vnt_rrv_time_cts {
-	__le16 cts_rrv_time_ba;
-	u16 wReserved;
-	__le16 rrv_time_b;
-	__le16 rrv_time_a;
-} __packed;
-
-struct vnt_rrv_time_ab {
-	__le16 rts_rrv_time;
-	__le16 rrv_time;
-} __packed;
-
-/* TX data header */
-struct vnt_tx_datahead_g {
-	struct vnt_phy_field b;
-	struct vnt_phy_field a;
-	__le16 duration_b;
-	__le16 duration_a;
-	__le16 time_stamp_off_b;
-	__le16 time_stamp_off_a;
-} __packed;
-
-struct vnt_tx_datahead_ab {
-	struct vnt_phy_field ab;
-	__le16 duration;
-	__le16 time_stamp_off;
-} __packed;
-
-/* RTS buffer header */
-struct vnt_rts_g {
-	struct vnt_phy_field b;
-	struct vnt_phy_field a;
-	__le16 duration_ba;
-	__le16 duration_aa;
-	__le16 duration_bb;
-	u16 wReserved;
-	struct ieee80211_rts data;
-	struct vnt_tx_datahead_g data_head;
-} __packed __aligned(2);
-
-struct vnt_rts_ab {
-	struct vnt_phy_field ab;
-	__le16 duration;
-	u16 wReserved;
-	struct ieee80211_rts data;
-	struct vnt_tx_datahead_ab data_head;
-} __packed __aligned(2);
-
-/* CTS buffer header */
-struct vnt_cts {
-	struct vnt_phy_field b;
-	__le16 duration_ba;
-	u16 wReserved;
-	struct ieee80211_cts data;
-	u16 reserved2;
-	struct vnt_tx_datahead_g data_head;
-} __packed __aligned(2);
-
-union vnt_tx_data_head {
-	/* rts g */
-	struct vnt_rts_g rts_g;
-	/* rts a/b */
-	struct vnt_rts_ab rts_ab;
-	/* cts g */
-	struct vnt_cts cts_g;
-	/* no rts/cts */
-	struct vnt_tx_datahead_ab data_head_ab;
-};
-
-struct vnt_tx_mic_hdr {
-	struct vnt_mic_hdr hdr;
-	union vnt_tx_data_head head;
-} __packed;
-
-union vnt_tx {
-	struct vnt_tx_mic_hdr mic;
-	union vnt_tx_data_head head;
-};
-
-union vnt_tx_head {
-	struct {
-		struct vnt_rrv_time_rts rts;
-		union vnt_tx tx;
-	} __packed tx_rts;
-	struct {
-		struct vnt_rrv_time_cts cts;
-		union vnt_tx tx;
-	} __packed tx_cts;
-	struct {
-		struct vnt_rrv_time_ab ab;
-		union vnt_tx tx;
-	} __packed tx_ab;
-};
-
-struct vnt_tx_fifo_head {
-	u8 tx_key[WLAN_KEY_LEN_CCMP];
-	__le16 fifo_ctl;
-	__le16 time_stamp;
-	__le16 frag_ctl;
-	__le16 current_rate;
-} __packed;
-
-struct vnt_tx_buffer {
-	struct vnt_tx_fifo_head fifo_head;
-	union vnt_tx_head tx_head;
-} __packed;
-
-struct vnt_tx_short_buf_head {
-	__le16 fifo_ctl;
-	u16 time_stamp;
-	struct vnt_phy_field ab;
-	__le16 duration;
-	__le16 time_stamp_off;
-} __packed;
-
-int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb);
-int vnt_beacon_make(struct vnt_private *priv, struct ieee80211_vif *vif);
-int vnt_beacon_enable(struct vnt_private *priv, struct ieee80211_vif *vif,
-		      struct ieee80211_bss_conf *conf);
-
-#endif /* __RXTX_H__ */
diff --git a/drivers/staging/vt6656/usbpipe.c b/drivers/staging/vt6656/usbpipe.c
deleted file mode 100644
index d505b4b69ba4..000000000000
--- a/drivers/staging/vt6656/usbpipe.c
+++ /dev/null
@@ -1,506 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * Purpose: Handle USB control endpoint
- *
- * Author: Warren Hsu
- *
- * Date: Mar. 29, 2005
- *
- * Functions:
- *	vnt_control_out - Write variable length bytes to MEM/BB/MAC/EEPROM
- *	vnt_control_in - Read variable length bytes from MEM/BB/MAC/EEPROM
- *	vnt_control_out_u8 - Write one byte to MEM/BB/MAC/EEPROM
- *	vnt_control_in_u8 - Read one byte from MEM/BB/MAC/EEPROM
- *
- * Revision History:
- *      04-05-2004 Jerry Chen: Initial release
- *      11-24-2004 Warren Hsu: Add ControlvWriteByte,ControlvReadByte,
- *                             ControlvMaskByte
- *
- */
-
-#include "rxtx.h"
-#include "desc.h"
-#include "device.h"
-#include "usbpipe.h"
-#include "mac.h"
-#include "rf.h"
-
-#define USB_CTL_WAIT	500 /* ms */
-
-int vnt_control_out(struct vnt_private *priv, u8 request, u16 value,
-		    u16 index, u16 length, const u8 *buffer)
-{
-	int ret = 0;
-	u8 *usb_buffer;
-
-	if (test_bit(DEVICE_FLAGS_DISCONNECTED, &priv->flags)) {
-		ret = -EINVAL;
-		goto end;
-	}
-
-	mutex_lock(&priv->usb_lock);
-
-	usb_buffer = kmemdup(buffer, length, GFP_KERNEL);
-	if (!usb_buffer) {
-		ret = -ENOMEM;
-		goto end_unlock;
-	}
-
-	ret = usb_control_msg(priv->usb,
-			      usb_sndctrlpipe(priv->usb, 0),
-			      request, 0x40, value,
-			      index, usb_buffer, length, USB_CTL_WAIT);
-
-	kfree(usb_buffer);
-
-	if (ret == (int)length)
-		ret = 0;
-	else
-		ret = -EIO;
-
-end_unlock:
-	mutex_unlock(&priv->usb_lock);
-end:
-	return ret;
-}
-
-int vnt_control_out_u8(struct vnt_private *priv, u8 reg, u8 reg_off, u8 data)
-{
-	return vnt_control_out(priv, MESSAGE_TYPE_WRITE,
-			       reg_off, reg, sizeof(u8), &data);
-}
-
-int vnt_control_out_blocks(struct vnt_private *priv,
-			   u16 block, u8 reg, u16 length, const u8 *data)
-{
-	int ret = 0, i;
-
-	for (i = 0; i < length; i += block) {
-		u16 len = min_t(int, length - i, block);
-
-		ret = vnt_control_out(priv, MESSAGE_TYPE_WRITE,
-				      i, reg, len, data + i);
-		if (ret)
-			goto end;
-	}
-end:
-	return ret;
-}
-
-int vnt_control_in(struct vnt_private *priv, u8 request, u16 value,
-		   u16 index, u16 length, u8 *buffer)
-{
-	int ret = 0;
-	u8 *usb_buffer;
-
-	if (test_bit(DEVICE_FLAGS_DISCONNECTED, &priv->flags)) {
-		ret = -EINVAL;
-		goto end;
-	}
-
-	mutex_lock(&priv->usb_lock);
-
-	usb_buffer = kmalloc(length, GFP_KERNEL);
-	if (!usb_buffer) {
-		ret = -ENOMEM;
-		goto end_unlock;
-	}
-
-	ret = usb_control_msg(priv->usb,
-			      usb_rcvctrlpipe(priv->usb, 0),
-			      request, 0xc0, value,
-			      index, usb_buffer, length, USB_CTL_WAIT);
-
-	if (ret == length)
-		memcpy(buffer, usb_buffer, length);
-
-	kfree(usb_buffer);
-
-	if (ret == (int)length)
-		ret = 0;
-	else
-		ret = -EIO;
-
-end_unlock:
-	mutex_unlock(&priv->usb_lock);
-end:
-	return ret;
-}
-
-int vnt_control_in_u8(struct vnt_private *priv, u8 reg, u8 reg_off, u8 *data)
-{
-	return vnt_control_in(priv, MESSAGE_TYPE_READ,
-			      reg_off, reg, sizeof(u8), data);
-}
-
-static int vnt_int_report_rate(struct vnt_private *priv, u8 pkt_no, u8 tsr)
-{
-	struct vnt_usb_send_context *context;
-	struct ieee80211_tx_info *info;
-	u8 tx_retry = (tsr & 0xf0) >> 4;
-	s8 idx;
-
-	if (pkt_no >= priv->num_tx_context)
-		return -EINVAL;
-
-	context = priv->tx_context[pkt_no];
-
-	if (!context->skb)
-		return -EINVAL;
-
-	info = IEEE80211_SKB_CB(context->skb);
-	idx = info->control.rates[0].idx;
-
-	ieee80211_tx_info_clear_status(info);
-
-	info->status.rates[0].count = tx_retry;
-
-	if (!(tsr & TSR_TMO)) {
-		info->status.rates[0].idx = idx;
-
-		if (!(info->flags & IEEE80211_TX_CTL_NO_ACK))
-			info->flags |= IEEE80211_TX_STAT_ACK;
-	}
-
-	ieee80211_tx_status_irqsafe(priv->hw, context->skb);
-
-	context->in_use = false;
-
-	return 0;
-}
-
-static void vnt_int_process_data(struct vnt_private *priv)
-{
-	struct vnt_interrupt_data *int_data;
-	struct ieee80211_low_level_stats *low_stats = &priv->low_stats;
-
-	dev_dbg(&priv->usb->dev, "---->s_nsInterruptProcessData\n");
-
-	int_data = (struct vnt_interrupt_data *)priv->int_buf.data_buf;
-
-	if (int_data->tsr0 & TSR_VALID)
-		vnt_int_report_rate(priv, int_data->pkt0, int_data->tsr0);
-
-	if (int_data->tsr1 & TSR_VALID)
-		vnt_int_report_rate(priv, int_data->pkt1, int_data->tsr1);
-
-	if (int_data->tsr2 & TSR_VALID)
-		vnt_int_report_rate(priv, int_data->pkt2, int_data->tsr2);
-
-	if (int_data->tsr3 & TSR_VALID)
-		vnt_int_report_rate(priv, int_data->pkt3, int_data->tsr3);
-
-	if (!int_data->isr0)
-		return;
-
-	if (int_data->isr0 & ISR_BNTX && priv->op_mode == NL80211_IFTYPE_AP)
-		vnt_schedule_command(priv, WLAN_CMD_BECON_SEND);
-
-	priv->current_tsf = le64_to_cpu(int_data->tsf);
-
-	low_stats->dot11RTSSuccessCount += int_data->rts_success;
-	low_stats->dot11RTSFailureCount += int_data->rts_fail;
-	low_stats->dot11ACKFailureCount += int_data->ack_fail;
-	low_stats->dot11FCSErrorCount += int_data->fcs_err;
-}
-
-static void vnt_start_interrupt_urb_complete(struct urb *urb)
-{
-	struct vnt_private *priv = urb->context;
-	int status = urb->status;
-
-	switch (status) {
-	case 0:
-	case -ETIMEDOUT:
-		break;
-	case -ECONNRESET:
-	case -ENOENT:
-	case -ESHUTDOWN:
-		return;
-	default:
-		break;
-	}
-
-	if (status)
-		dev_dbg(&priv->usb->dev, "%s status = %d\n", __func__, status);
-	else
-		vnt_int_process_data(priv);
-
-	if (!test_bit(DEVICE_FLAGS_DISCONNECTED, &priv->flags))
-		status = usb_submit_urb(priv->interrupt_urb, GFP_ATOMIC);
-
-	if (status)
-		dev_dbg(&priv->usb->dev, "Submit int URB failed %d\n", status);
-}
-
-int vnt_start_interrupt_urb(struct vnt_private *priv)
-{
-	int ret = 0;
-
-	dev_dbg(&priv->usb->dev, "---->Interrupt Polling Thread\n");
-
-	usb_fill_int_urb(priv->interrupt_urb,
-			 priv->usb,
-			 usb_rcvintpipe(priv->usb, 1),
-			 priv->int_buf.data_buf,
-			 MAX_INTERRUPT_SIZE,
-			 vnt_start_interrupt_urb_complete,
-			 priv,
-			 priv->int_interval);
-
-	ret = usb_submit_urb(priv->interrupt_urb, GFP_ATOMIC);
-	if (ret)
-		dev_dbg(&priv->usb->dev, "Submit int URB failed %d\n", ret);
-
-	return ret;
-}
-
-static int vnt_rx_data(struct vnt_private *priv, struct vnt_rcb *ptr_rcb,
-		       unsigned long bytes_received)
-{
-	struct ieee80211_hw *hw = priv->hw;
-	struct ieee80211_supported_band *sband;
-	struct sk_buff *skb;
-	struct ieee80211_rx_status *rx_status;
-	struct vnt_rx_header *head;
-	struct vnt_rx_tail *tail;
-	u32 frame_size;
-	int ii;
-	u16 rx_bitrate, pay_load_with_padding;
-	u8 rate_idx = 0;
-	long rx_dbm;
-
-	skb = ptr_rcb->skb;
-	rx_status = IEEE80211_SKB_RXCB(skb);
-
-	/* [31:16]RcvByteCount ( not include 4-byte Status ) */
-	head = (struct vnt_rx_header *)skb->data;
-	frame_size = head->wbk_status >> 16;
-	frame_size += 4;
-
-	if (bytes_received != frame_size) {
-		dev_dbg(&priv->usb->dev, "------- WRONG Length 1\n");
-		return false;
-	}
-
-	if ((bytes_received > 2372) || (bytes_received <= 40)) {
-		/* Frame Size error drop this packet.*/
-		dev_dbg(&priv->usb->dev, "------ WRONG Length 2\n");
-		return false;
-	}
-
-	/* real Frame Size = USBframe_size -4WbkStatus - 4RxStatus */
-	/* -8TSF - 4RSR - 4SQ3 - ?Padding */
-
-	/* if SQ3 the range is 24~27, if no SQ3 the range is 20~23 */
-
-	/*Fix hardware bug => PLCP_Length error */
-	if (((bytes_received - head->pay_load_len) > 27) ||
-	    ((bytes_received - head->pay_load_len) < 24) ||
-	    (bytes_received < head->pay_load_len)) {
-		dev_dbg(&priv->usb->dev, "Wrong PLCP Length %x\n",
-			head->pay_load_len);
-		return false;
-	}
-
-	sband = hw->wiphy->bands[hw->conf.chandef.chan->band];
-	rx_bitrate = head->rx_rate * 5; /* rx_rate * 5 */
-
-	for (ii = 0; ii < sband->n_bitrates; ii++) {
-		if (sband->bitrates[ii].bitrate == rx_bitrate) {
-			rate_idx = ii;
-				break;
-		}
-	}
-
-	if (ii == sband->n_bitrates) {
-		dev_dbg(&priv->usb->dev, "Wrong Rx Bit Rate %d\n", rx_bitrate);
-		return false;
-	}
-
-	pay_load_with_padding = ((head->pay_load_len / 4) +
-		((head->pay_load_len % 4) ? 1 : 0)) * 4;
-
-	tail = (struct vnt_rx_tail *)(skb->data +
-				      sizeof(*head) + pay_load_with_padding);
-	priv->tsf_time = le64_to_cpu(tail->tsf_time);
-
-	if (tail->rsr & (RSR_IVLDTYP | RSR_IVLDLEN))
-		return false;
-
-	vnt_rf_rssi_to_dbm(priv, tail->rssi, &rx_dbm);
-
-	priv->bb_pre_ed_rssi = (u8)-rx_dbm + 1;
-	priv->current_rssi = priv->bb_pre_ed_rssi;
-
-	skb_pull(skb, sizeof(*head));
-	skb_trim(skb, head->pay_load_len);
-
-	rx_status->mactime = priv->tsf_time;
-	rx_status->band = hw->conf.chandef.chan->band;
-	rx_status->signal = rx_dbm;
-	rx_status->flag = 0;
-	rx_status->freq = hw->conf.chandef.chan->center_freq;
-
-	if (!(tail->rsr & RSR_CRCOK))
-		rx_status->flag |= RX_FLAG_FAILED_FCS_CRC;
-
-	rx_status->rate_idx = rate_idx;
-
-	if (tail->new_rsr & NEWRSR_DECRYPTOK)
-		rx_status->flag |= RX_FLAG_DECRYPTED;
-
-	ieee80211_rx_irqsafe(priv->hw, skb);
-
-	return true;
-}
-
-static void vnt_submit_rx_urb_complete(struct urb *urb)
-{
-	struct vnt_rcb *rcb = urb->context;
-	struct vnt_private *priv = rcb->priv;
-
-	switch (urb->status) {
-	case 0:
-		break;
-	case -ECONNRESET:
-	case -ENOENT:
-	case -ESHUTDOWN:
-		return;
-	case -ETIMEDOUT:
-	default:
-		dev_dbg(&priv->usb->dev, "BULK In failed %d\n", urb->status);
-		break;
-	}
-
-	if (urb->actual_length) {
-		if (vnt_rx_data(priv, rcb, urb->actual_length)) {
-			rcb->skb = dev_alloc_skb(priv->rx_buf_sz);
-			if (!rcb->skb)
-				return;
-		} else {
-			skb_push(rcb->skb, skb_headroom(rcb->skb));
-			skb_trim(rcb->skb, 0);
-		}
-
-		urb->transfer_buffer = skb_put(rcb->skb,
-					       skb_tailroom(rcb->skb));
-	}
-
-	if (usb_submit_urb(urb, GFP_ATOMIC))
-		dev_dbg(&priv->usb->dev, "Failed to re submit rx skb\n");
-}
-
-int vnt_submit_rx_urb(struct vnt_private *priv, struct vnt_rcb *rcb)
-{
-	int ret = 0;
-	struct urb *urb = rcb->urb;
-
-	if (!rcb->skb) {
-		dev_dbg(&priv->usb->dev, "rcb->skb is null\n");
-		ret = -EINVAL;
-		goto end;
-	}
-
-	usb_fill_bulk_urb(urb,
-			  priv->usb,
-			  usb_rcvbulkpipe(priv->usb, 2),
-			  skb_put(rcb->skb, skb_tailroom(rcb->skb)),
-			  MAX_TOTAL_SIZE_WITH_ALL_HEADERS,
-			  vnt_submit_rx_urb_complete,
-			  rcb);
-
-	ret = usb_submit_urb(urb, GFP_ATOMIC);
-	if (ret)
-		dev_dbg(&priv->usb->dev, "Submit Rx URB failed %d\n", ret);
-end:
-	return ret;
-}
-
-static void vnt_tx_context_complete(struct urb *urb)
-{
-	struct vnt_usb_send_context *context = urb->context;
-	struct vnt_private *priv = context->priv;
-
-	switch (urb->status) {
-	case 0:
-		dev_dbg(&priv->usb->dev,
-			"Write %d bytes\n", urb->actual_length);
-		break;
-	case -ECONNRESET:
-	case -ENOENT:
-	case -ESHUTDOWN:
-		context->in_use = false;
-		return;
-	case -ETIMEDOUT:
-	default:
-		dev_dbg(&priv->usb->dev, "BULK Out failed %d\n", urb->status);
-		break;
-	}
-
-	if (context->type == CONTEXT_DATA_PACKET)
-		ieee80211_wake_queues(priv->hw);
-
-	if (urb->status || context->type == CONTEXT_BEACON_PACKET) {
-		if (context->skb)
-			ieee80211_free_txskb(priv->hw, context->skb);
-
-		context->in_use = false;
-	}
-}
-
-int vnt_tx_context(struct vnt_private *priv,
-		   struct vnt_usb_send_context *context,
-		   struct sk_buff *skb)
-{
-	struct vnt_tx_usb_header *usb;
-	struct urb *urb;
-	int status;
-	u16 count = skb->len;
-
-	usb = skb_push(skb, sizeof(*usb));
-	usb->tx_byte_count = cpu_to_le16(count);
-	usb->pkt_no = context->pkt_no;
-	usb->type = context->type;
-
-	if (test_bit(DEVICE_FLAGS_DISCONNECTED, &priv->flags)) {
-		context->in_use = false;
-		return -ENODEV;
-	}
-
-	if (skb->len > MAX_TOTAL_SIZE_WITH_ALL_HEADERS) {
-		context->in_use = false;
-		return -E2BIG;
-	}
-
-	urb = usb_alloc_urb(0, GFP_ATOMIC);
-	if (!urb) {
-		context->in_use = false;
-		return -ENOMEM;
-	}
-
-	usb_fill_bulk_urb(urb,
-			  priv->usb,
-			  usb_sndbulkpipe(priv->usb, 3),
-			  skb->data,
-			  skb->len,
-			  vnt_tx_context_complete,
-			  context);
-
-	usb_anchor_urb(urb, &priv->tx_submitted);
-
-	status = usb_submit_urb(urb, GFP_ATOMIC);
-	if (status) {
-		dev_dbg(&priv->usb->dev, "Submit Tx URB failed %d\n", status);
-		usb_unanchor_urb(urb);
-		context->in_use = false;
-	}
-
-	usb_free_urb(urb);
-
-	return status;
-}
diff --git a/drivers/staging/vt6656/usbpipe.h b/drivers/staging/vt6656/usbpipe.h
deleted file mode 100644
index 922312e299bf..000000000000
--- a/drivers/staging/vt6656/usbpipe.h
+++ /dev/null
@@ -1,67 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * Purpose:
- *
- * Author: Warren Hsu
- *
- * Date: Mar. 30, 2005
- *
- */
-
-#ifndef __USBPIPE_H__
-#define __USBPIPE_H__
-
-#include "device.h"
-
-struct vnt_interrupt_data {
-	u8 tsr0;
-	u8 pkt0;
-	u16 time0;
-	u8 tsr1;
-	u8 pkt1;
-	u16 time1;
-	u8 tsr2;
-	u8 pkt2;
-	u16 time2;
-	u8 tsr3;
-	u8 pkt3;
-	u16 time3;
-	__le64 tsf;
-	u8 isr0;
-	u8 isr1;
-	u8 rts_success;
-	u8 rts_fail;
-	u8 ack_fail;
-	u8 fcs_err;
-	u8 sw[2];
-} __packed;
-
-struct vnt_tx_usb_header {
-	u8 type;
-	u8 pkt_no;
-	__le16 tx_byte_count;
-} __packed;
-
-#define VNT_REG_BLOCK_SIZE	64
-
-int vnt_control_out(struct vnt_private *priv, u8 request, u16 value,
-		    u16 index, u16 length, const u8 *buffer);
-int vnt_control_in(struct vnt_private *priv, u8 request, u16 value,
-		   u16 index, u16 length,  u8 *buffer);
-
-int vnt_control_out_u8(struct vnt_private *priv, u8 reg, u8 ref_off, u8 data);
-int vnt_control_in_u8(struct vnt_private *priv, u8 reg, u8 reg_off, u8 *data);
-
-int vnt_control_out_blocks(struct vnt_private *priv,
-			   u16 block, u8 reg, u16 len, const u8 *data);
-
-int vnt_start_interrupt_urb(struct vnt_private *priv);
-int vnt_submit_rx_urb(struct vnt_private *priv, struct vnt_rcb *rcb);
-int vnt_tx_context(struct vnt_private *priv,
-		   struct vnt_usb_send_context *context,
-		   struct sk_buff *skb);
-
-#endif /* __USBPIPE_H__ */
diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
deleted file mode 100644
index 14b8aa587119..000000000000
--- a/drivers/staging/vt6656/wcmd.c
+++ /dev/null
@@ -1,185 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * Purpose: Handles the management command interface functions
- *
- * Author: Lyndon Chen
- *
- * Date: May 8, 2003
- *
- * Functions:
- *	vnt_cmd_complete - Command Complete function
- *	vnt_schedule_command - Push Command and wait Command Scheduler to do
- *	vnt_cmd_timer_wait- Call back timer
- *
- * Revision History:
- *
- */
-
-#include "device.h"
-#include "mac.h"
-#include "wcmd.h"
-#include "power.h"
-#include "usbpipe.h"
-#include "rxtx.h"
-#include "rf.h"
-
-static void vnt_cmd_timer_wait(struct vnt_private *priv, unsigned long msecs)
-{
-	schedule_delayed_work(&priv->run_command_work, msecs_to_jiffies(msecs));
-}
-
-static u32 add_one_with_wrap_around(u32 var, u8 modulo)
-{
-	if (var >= (modulo - 1))
-		var = 0;
-	else
-		var++;
-	return var;
-}
-
-static int vnt_cmd_complete(struct vnt_private *priv)
-{
-	priv->command_state = WLAN_CMD_IDLE;
-	if (priv->free_cmd_queue == CMD_Q_SIZE) {
-		/* Command Queue Empty */
-		priv->cmd_running = false;
-		return true;
-	}
-
-	priv->command = priv->cmd_queue[priv->cmd_dequeue_idx];
-
-	priv->cmd_dequeue_idx = add_one_with_wrap_around(priv->cmd_dequeue_idx, CMD_Q_SIZE);
-	priv->free_cmd_queue++;
-	priv->cmd_running = true;
-
-	switch (priv->command) {
-	case WLAN_CMD_INIT_MAC80211:
-		priv->command_state = WLAN_CMD_INIT_MAC80211_START;
-		break;
-
-	case WLAN_CMD_TBTT_WAKEUP:
-		priv->command_state = WLAN_CMD_TBTT_WAKEUP_START;
-		break;
-
-	case WLAN_CMD_BECON_SEND:
-		priv->command_state = WLAN_CMD_BECON_SEND_START;
-		break;
-
-	case WLAN_CMD_SETPOWER:
-		priv->command_state = WLAN_CMD_SETPOWER_START;
-		break;
-
-	case WLAN_CMD_CHANGE_ANTENNA:
-		priv->command_state = WLAN_CMD_CHANGE_ANTENNA_START;
-		break;
-
-	default:
-		break;
-	}
-
-	vnt_cmd_timer_wait(priv, 0);
-
-	return true;
-}
-
-void vnt_run_command(struct work_struct *work)
-{
-	struct vnt_private *priv =
-		container_of(work, struct vnt_private, run_command_work.work);
-
-	if (test_bit(DEVICE_FLAGS_DISCONNECTED, &priv->flags))
-		return;
-
-	if (!priv->cmd_running)
-		return;
-
-	switch (priv->command_state) {
-	case WLAN_CMD_INIT_MAC80211_START:
-		if (priv->mac_hw)
-			break;
-
-		dev_info(&priv->usb->dev, "Starting mac80211\n");
-
-		if (vnt_init(priv)) {
-			/* If fail all ends TODO retry */
-			dev_err(&priv->usb->dev, "failed to start\n");
-			usb_set_intfdata(priv->intf, NULL);
-			ieee80211_free_hw(priv->hw);
-			return;
-		}
-
-		break;
-
-	case WLAN_CMD_TBTT_WAKEUP_START:
-		vnt_next_tbtt_wakeup(priv);
-		break;
-
-	case WLAN_CMD_BECON_SEND_START:
-		if (!priv->vif)
-			break;
-
-		vnt_beacon_make(priv, priv->vif);
-
-		vnt_mac_reg_bits_on(priv, MAC_REG_TCR, TCR_AUTOBCNTX);
-
-		break;
-
-	case WLAN_CMD_SETPOWER_START:
-
-		vnt_rf_setpower(priv, priv->hw->conf.chandef.chan);
-
-		break;
-
-	case WLAN_CMD_CHANGE_ANTENNA_START:
-		dev_dbg(&priv->usb->dev, "Change from Antenna%d to",
-			priv->rx_antenna_sel);
-
-		if (priv->rx_antenna_sel == 0) {
-			priv->rx_antenna_sel = 1;
-			if (priv->tx_rx_ant_inv)
-				vnt_set_antenna_mode(priv, ANT_RXA);
-			else
-				vnt_set_antenna_mode(priv, ANT_RXB);
-		} else {
-			priv->rx_antenna_sel = 0;
-			if (priv->tx_rx_ant_inv)
-				vnt_set_antenna_mode(priv, ANT_RXB);
-			else
-				vnt_set_antenna_mode(priv, ANT_RXA);
-		}
-		break;
-
-	default:
-		break;
-	}
-
-	vnt_cmd_complete(priv);
-}
-
-int vnt_schedule_command(struct vnt_private *priv, enum vnt_cmd command)
-{
-	if (priv->free_cmd_queue == 0)
-		return false;
-
-	priv->cmd_queue[priv->cmd_enqueue_idx] = command;
-
-	priv->cmd_enqueue_idx = add_one_with_wrap_around(priv->cmd_enqueue_idx, CMD_Q_SIZE);
-	priv->free_cmd_queue--;
-
-	if (!priv->cmd_running)
-		vnt_cmd_complete(priv);
-
-	return true;
-}
-
-void vnt_reset_command_timer(struct vnt_private *priv)
-{
-	priv->free_cmd_queue = CMD_Q_SIZE;
-	priv->cmd_dequeue_idx = 0;
-	priv->cmd_enqueue_idx = 0;
-	priv->command_state = WLAN_CMD_IDLE;
-	priv->cmd_running = false;
-}
diff --git a/drivers/staging/vt6656/wcmd.h b/drivers/staging/vt6656/wcmd.h
deleted file mode 100644
index a62924671b17..000000000000
--- a/drivers/staging/vt6656/wcmd.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * Purpose: Handles the management command interface functions
- *
- * Author: Lyndon Chen
- *
- * Date: May 8, 2002
- *
- */
-
-#ifndef __WCMD_H__
-#define __WCMD_H__
-
-#include "device.h"
-
-/* Command code */
-enum vnt_cmd {
-	WLAN_CMD_INIT_MAC80211,
-	WLAN_CMD_SETPOWER,
-	WLAN_CMD_TBTT_WAKEUP,
-	WLAN_CMD_BECON_SEND,
-	WLAN_CMD_CHANGE_ANTENNA
-};
-
-#define CMD_Q_SIZE              32
-
-/* Command state */
-enum vnt_cmd_state {
-	WLAN_CMD_INIT_MAC80211_START,
-	WLAN_CMD_SETPOWER_START,
-	WLAN_CMD_TBTT_WAKEUP_START,
-	WLAN_CMD_BECON_SEND_START,
-	WLAN_CMD_CHANGE_ANTENNA_START,
-	WLAN_CMD_IDLE
-};
-
-struct vnt_private;
-
-void vnt_reset_command_timer(struct vnt_private *priv);
-
-int vnt_schedule_command(struct vnt_private *priv, enum vnt_cmd);
-
-void vnt_run_command(struct work_struct *work);
-
-#endif /* __WCMD_H__ */
-- 
2.43.0


